--- a/config/Config-build.in
+++ b/config/Config-build.in
@@ -74,7 +74,7 @@
 		default n
 
 	config BUILD_PATENTED
-		default n
+		default y
 		bool "Compile with support for patented functionality"
 		help
 		  When this option is disabled, software which provides patented functionality

--- a/config/Config-images.in
+++ b/config/Config-images.in
@@ -92,7 +92,7 @@
 
 	menuconfig TARGET_ROOTFS_EXT4FS
 		bool "ext4"
-		default y if USES_EXT4
+		default n
 		help
 		  Build an ext4 root filesystem.
 
@@ -243,7 +243,7 @@
 	config GRUB_TIMEOUT
 		string "Seconds to wait before booting the default entry"
 		depends on GRUB_IMAGES || GRUB_EFI_IMAGES
-		default "5"
+		default "0"
 		help
 		  If you don't know, 5 seconds is a reasonable default.
 

--- a/include/version.mk
+++ b/include/version.mk
@@ -29,7 +29,7 @@
 VERSION_CODE:=$(if $(VERSION_CODE),$(VERSION_CODE),$(REVISION))
 
 VERSION_REPO:=$(call qstrip,$(CONFIG_VERSION_REPO))
-VERSION_REPO:=$(if $(VERSION_REPO),$(VERSION_REPO),https://downloads.openwrt.org/snapshots)
+VERSION_REPO:=$(if $(VERSION_REPO),$(VERSION_REPO),https://mirrors.tencent.com/openwrt/snapshots)
 
 VERSION_DIST:=$(call qstrip,$(CONFIG_VERSION_DIST))
 VERSION_DIST:=$(if $(VERSION_DIST),$(VERSION_DIST),OpenWrt)

--- a/package/base-files/files/bin/config_generate
+++ b/package/base-files/files/bin/config_generate
@@ -161,8 +161,8 @@
 		static)
 			local ipad
 			case "$1" in
-				lan) ipad=${ipaddr:-"192.168.1.1"} ;;
-				*) ipad=${ipaddr:-"192.168.$((addr_offset++)).1"} ;;
+				lan) ipad=${ipaddr:-"10.0.0.1"} ;;
+				*) ipad=${ipaddr:-"10.0.$((addr_offset++)).1"} ;;
 			esac
 
 			netm=${netmask:-"255.255.255.0"}
@@ -176,18 +176,7 @@
 		;;
 
 		dhcp)
-			# fixup IPv6 slave interface if parent is a bridge
-			[ "$type" = "bridge" ] && device="br-$1"
-
 			uci set network.$1.proto='dhcp'
-			[ -e /proc/sys/net/ipv6 ] && {
-				uci -q batch <<-EOF
-					delete network.${1}6
-					set network.${1}6='interface'
-					set network.${1}6.device='$device'
-					set network.${1}6.proto='dhcpv6'
-				EOF
-			}
 		;;
 
 		pppoe)
@@ -195,16 +184,8 @@
 				set network.$1.proto='pppoe'
 				set network.$1.username='username'
 				set network.$1.password='password'
+				set network.$1.ipv6='auto'
 			EOF
-			[ -e /proc/sys/net/ipv6 ] && {
-				uci -q batch <<-EOF
-					set network.$1.ipv6='1'
-					delete network.${1}6
-					set network.${1}6='interface'
-					set network.${1}6.device='@${1}'
-					set network.${1}6.proto='dhcpv6'
-				EOF
-			}
 		;;
 	esac
 }
@@ -302,7 +283,8 @@
 		delete system.@system[0]
 		add system system
 		set system.@system[-1].hostname='OpenWrt'
-		set system.@system[-1].timezone='UTC'
+		set system.@system[-1].zonename='Asia/Hong Kong'
+		set system.@system[-1].timezone='HKT-8'
 		set system.@system[-1].ttylogin='0'
 		set system.@system[-1].log_size='64'
 		set system.@system[-1].urandom_seed='0'
@@ -310,11 +292,9 @@
 		delete system.ntp
 		set system.ntp='timeserver'
 		set system.ntp.enabled='1'
-		set system.ntp.enable_server='0'
-		add_list system.ntp.server='0.openwrt.pool.ntp.org'
-		add_list system.ntp.server='1.openwrt.pool.ntp.org'
-		add_list system.ntp.server='2.openwrt.pool.ntp.org'
-		add_list system.ntp.server='3.openwrt.pool.ntp.org'
+		set system.ntp.enable_server='1'
+		add_list system.ntp.server='ntp1.aliyun.com'
+		add_list system.ntp.server='time2.cloud.tencent.com'
 	EOF
 
 	if json_is_a system object; then

--- a/package/base-files/files/etc/board.d/99-default_network
+++ b/package/base-files/files/etc/board.d/99-default_network
@@ -8,8 +8,15 @@
 
 json_is_a network object && exit 0
 
-ucidef_set_interface_lan 'eth0'
-[ -d /sys/class/net/eth1 ] && ucidef_set_interface_wan 'eth1'
+A=$(ls /sys/class/net | grep -c eth)
+if [ $A -gt 1 ];then
+	let A=A-1
+	ucidef_set_interface_wan eth0
+	for i in $(seq 1 $A);do B="$B eth$i";done
+	ucidef_set_interface_lan "${B#* }"
+else
+	ucidef_set_interface_lan eth0
+fi
 
 board_config_flush
 

--- a/package/base-files/files/etc/sysctl.d/10-default.conf
+++ b/package/base-files/files/etc/sysctl.d/10-default.conf
@@ -25,3 +25,5 @@
 
 net.ipv6.conf.default.forwarding=1
 net.ipv6.conf.all.forwarding=1
+net.ipv6.conf.default.accept_ra=2
+net.ipv6.conf.all.accept_ra=2

--- a/package/base-files/image-config.in
+++ b/package/base-files/image-config.in
@@ -183,7 +183,7 @@
 	config VERSION_REPO
 		string
 		prompt "Release repository"
-		default "https://downloads.openwrt.org/snapshots"
+		default "https://mirrors.tencent.com/openwrt/snapshots"
 		help
 			This is the repository address embedded in the image, it defaults
 			to the trunk snapshot repo; the url may contain the following placeholders:

--- a/package/kernel/linux/files/sysctl-nf-conntrack.conf
+++ a/package/kernel/linux/files/sysctl-nf-conntrack.conf
@@ -3,7 +3,7 @@
 
 net.netfilter.nf_conntrack_acct=1
 net.netfilter.nf_conntrack_checksum=0
-net.netfilter.nf_conntrack_max=16384
+net.netfilter.nf_conntrack_max=65535
 net.netfilter.nf_conntrack_tcp_timeout_established=7440
 net.netfilter.nf_conntrack_udp_timeout=60
 net.netfilter.nf_conntrack_udp_timeout_stream=180

--- /dev/null
+++ b/package/libs/mbedtls/patches/100-Implements-AES-and-GCM-with-ARMv8-Crypto-Extensions.patch
@@ -0,0 +1,401 @@
+From dfb6015ca79a9fee28f7fcb0af7e350a83574b83 Mon Sep 17 00:00:00 2001
+From: "Markku-Juhani O. Saarinen" <mjos@mjos.fi>
+Date: Mon, 20 Nov 2017 14:58:41 +0000
+Subject: Implements AES and GCM with ARMv8 Crypto Extensions
+
+A compact patch that provides AES and GCM implementations that utilize the
+ARMv8 Crypto Extensions. The config flag is MBEDTLS_ARMV8CE_AES_C, which
+is disabled by default as we don't do runtime checking for the feature.
+The new implementation lives in armv8ce_aes.c.
+
+Provides similar functionality to https://github.com/ARMmbed/mbedtls/pull/432
+Thanks to Barry O'Rourke and others for that contribtion.
+
+Tested on a Cortex A53 device and QEMU. On a midrange phone the real AES-GCM
+throughput increases about 4x, while raw AES speed is up to 10x faster.
+
+When cross-compiling, you want to set something like:
+
+  export CC='aarch64-linux-gnu-gcc'
+  export CFLAGS='-Ofast -march=armv8-a+crypto'
+  scripts/config.pl set MBEDTLS_ARMV8CE_AES_C
+
+QEMU seems to also need
+
+  export LDFLAGS='-static'
+
+Then run normal make or cmake etc.
+---
+
+diff -ruNa --binary a/ChangeLog.d/armv8_crypto_extensions.txt b/ChangeLog.d/armv8_crypto_extensions.txt
+--- a/ChangeLog.d/armv8_crypto_extensions.txt	1970-01-01 08:00:00.000000000 +0800
++++ b/ChangeLog.d/armv8_crypto_extensions.txt	2021-03-07 15:07:17.781911791 +0800
+@@ -0,0 +1,2 @@
++Features
++    * Support ARMv8 Cryptography Extensions for AES and GCM.
+diff -ruNa --binary a/include/mbedtls/armv8ce_aes.h b/include/mbedtls/armv8ce_aes.h
+--- a/include/mbedtls/armv8ce_aes.h	1970-01-01 08:00:00.000000000 +0800
++++ b/include/mbedtls/armv8ce_aes.h	2021-03-07 15:07:17.781911791 +0800
+@@ -0,0 +1,63 @@
++/**
++ * \file armv8ce_aes.h
++ *
++ * \brief ARMv8 Cryptography Extensions -- Optimized code for AES and GCM
++ */
++
++/*
++ *
++ *  Copyright (C) 2006-2017, ARM Limited, All Rights Reserved
++ *  SPDX-License-Identifier: Apache-2.0
++ *
++ *  Licensed under the Apache License, Version 2.0 (the "License"); you may
++ *  not use this file except in compliance with the License.
++ *  You may obtain a copy of the License at
++ *
++ *  http://www.apache.org/licenses/LICENSE-2.0
++ *
++ *  Unless required by applicable law or agreed to in writing, software
++ *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
++ *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ *  See the License for the specific language governing permissions and
++ *  limitations under the License.
++ *
++ *  This file is part of mbed TLS (https://tls.mbed.org)
++ */
++
++#ifndef MBEDTLS_ARMV8CE_AES_H
++#define MBEDTLS_ARMV8CE_AES_H
++
++#include "aes.h"
++
++/**
++ * \brief          [ARMv8 Crypto Extensions] AES-ECB block en(de)cryption
++ *
++ * \param ctx      AES context
++ * \param mode     MBEDTLS_AES_ENCRYPT or MBEDTLS_AES_DECRYPT
++ * \param input    16-byte input block
++ * \param output   16-byte output block
++ *
++ * \return         0 on success (cannot fail)
++ */
++
++int mbedtls_armv8ce_aes_crypt_ecb( mbedtls_aes_context *ctx,
++                                   int mode,
++                                   const unsigned char input[16],
++                                   unsigned char output[16] );
++
++/**
++ * \brief          [ARMv8 Crypto Extensions]  Multiply in GF(2^128) for GCM
++ *
++ * \param c        Result
++ * \param a        First operand
++ * \param b        Second operand
++ *
++ * \note           Both operands and result are bit strings interpreted as
++ *                 elements of GF(2^128) as per the GCM spec.
++ */
++
++void mbedtls_armv8ce_gcm_mult( unsigned char c[16],
++                               const unsigned char a[16],
++                               const unsigned char b[16] );
++
++#endif /* MBEDTLS_ARMV8CE_AES_H */
+diff -ruNa --binary a/include/mbedtls/check_config.h b/include/mbedtls/check_config.h
+--- a/include/mbedtls/check_config.h	2020-12-10 20:54:15.000000000 +0800
++++ b/include/mbedtls/check_config.h	2021-03-07 15:06:45.625543309 +0800
+@@ -95,6 +95,10 @@
+ #error "MBEDTLS_AESNI_C defined, but not all prerequisites"
+ #endif
+ 
++#if defined(MBEDTLS_ARMV8CE_AES_C) && !defined(MBEDTLS_HAVE_ASM)
++#error "MBEDTLS_ARMV8CE_AES_C defined, but not all prerequisites"
++#endif
++
+ #if defined(MBEDTLS_CTR_DRBG_C) && !defined(MBEDTLS_AES_C)
+ #error "MBEDTLS_CTR_DRBG_C defined, but not all prerequisites"
+ #endif
+@@ -772,3 +776,4 @@
+ typedef int mbedtls_iso_c_forbids_empty_translation_units;
+ 
+ #endif /* MBEDTLS_CHECK_CONFIG_H */
++
+diff -ruNa --binary a/include/mbedtls/config.h b/include/mbedtls/config.h
+--- a/include/mbedtls/config.h	2020-12-10 20:54:15.000000000 +0800
++++ b/include/mbedtls/config.h	2021-03-07 15:14:27.957855484 +0800
+@@ -73,6 +73,7 @@
+  * Requires support for asm() in compiler.
+  *
+  * Used in:
++ *      library/armv8ce_aes.c
+  *      library/aria.c
+  *      library/timing.c
+  *      include/mbedtls/bn_mul.h
+@@ -1888,6 +1889,21 @@
+ #define MBEDTLS_AESNI_C
+ 
+ /**
++ * \def MBEDTLS_ARMV8CE_AES_C
++ *
++ * Enable ARMv8 Crypto Extensions for AES and GCM
++ *
++ * Module:  library/armv8ce_aes.c
++ * Caller:  library/aes.c
++ *          library/gcm.c
++ *
++ * Requires: MBEDTLS_HAVE_ASM
++ *
++ * This module adds support for Armv8 Cryptography Extensions for AES and GCM.
++ */
++//#define MBEDTLS_ARMV8CE_AES_C
++
++/**
+  * \def MBEDTLS_AES_C
+  *
+  * Enable the AES block cipher.
+diff -ruNa --binary a/library/aes.c b/library/aes.c
+--- a/library/aes.c	2020-12-10 20:54:15.000000000 +0800
++++ b/library/aes.c	2021-03-07 15:06:45.625543309 +0800
+@@ -69,7 +69,9 @@
+ #if defined(MBEDTLS_AESNI_C)
+ #include "mbedtls/aesni.h"
+ #endif
+-
++#if defined(MBEDTLS_ARMV8CE_AES_C)
++#include "mbedtls/armv8ce_aes.h"
++#endif
+ #if defined(MBEDTLS_SELF_TEST)
+ #if defined(MBEDTLS_PLATFORM_C)
+ #include "mbedtls/platform.h"
+@@ -1052,6 +1054,11 @@
+         return( mbedtls_aesni_crypt_ecb( ctx, mode, input, output ) );
+ #endif
+ 
++#if defined(MBEDTLS_ARMV8CE_AES_C)
++	// We don't do runtime checking for ARMv8 Crypto Extensions
++	return mbedtls_armv8ce_aes_crypt_ecb( ctx, mode, input, output );
++#endif
++
+ #if defined(MBEDTLS_PADLOCK_C) && defined(MBEDTLS_HAVE_X86)
+     if( aes_padlock_ace )
+     {
+diff -ruNa --binary a/library/armv8ce_aes.c b/library/armv8ce_aes.c
+--- a/library/armv8ce_aes.c	1970-01-01 08:00:00.000000000 +0800
++++ b/library/armv8ce_aes.c	2021-03-07 15:07:17.781911791 +0800
+@@ -0,0 +1,142 @@
++/*
++ *  ARMv8 Cryptography Extensions -- Optimized code for AES and GCM
++ *
++ *  Copyright (C) 2006-2017, ARM Limited, All Rights Reserved
++ *  SPDX-License-Identifier: Apache-2.0
++ *
++ *  Licensed under the Apache License, Version 2.0 (the "License"); you may
++ *  not use this file except in compliance with the License.
++ *  You may obtain a copy of the License at
++ *
++ *  http://www.apache.org/licenses/LICENSE-2.0
++ *
++ *  Unless required by applicable law or agreed to in writing, software
++ *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
++ *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ *  See the License for the specific language governing permissions and
++ *  limitations under the License.
++ *
++ *  This file is part of mbed TLS (https://tls.mbed.org)
++ */
++
++#if !defined(MBEDTLS_CONFIG_FILE)
++#include "mbedtls/config.h"
++#else
++#include MBEDTLS_CONFIG_FILE
++#endif
++
++#if defined(MBEDTLS_ARMV8CE_AES_C)
++
++#include <arm_neon.h>
++#include "mbedtls/armv8ce_aes.h"
++
++#ifndef asm
++#define asm __asm
++#endif
++
++/*
++ *  [Armv8 Cryptography Extensions]  AES-ECB block en(de)cryption
++ */
++
++#if defined(MBEDTLS_AES_C)
++
++int mbedtls_armv8ce_aes_crypt_ecb( mbedtls_aes_context *ctx,
++                                   int mode,
++                                   const unsigned char input[16],
++                                   unsigned char output[16] )
++{
++    unsigned int i;
++    const uint8_t *rk;
++    uint8x16_t x, k;
++
++    x = vld1q_u8( input );                          /* input block */
++    rk = (const uint8_t *) ctx->rk;                 /* round keys  */
++
++    if( mode == MBEDTLS_AES_ENCRYPT )
++    {
++        for( i = ctx->nr - 1; i != 0; i-- )         /* encryption loop */
++        {
++            k = vld1q_u8( rk );
++            rk += 16;
++            x = vaeseq_u8( x, k );
++            x = vaesmcq_u8( x );
++        }
++        k = vld1q_u8( rk );
++        rk += 16;
++        x = vaeseq_u8( x, k );
++    }
++    else
++    {
++        for( i = ctx->nr - 1; i != 0 ; i-- )         /* decryption loop */
++        {
++            k = vld1q_u8( rk );
++            rk += 16;
++            x = vaesdq_u8( x, k );
++            x = vaesimcq_u8( x );
++        }
++        k = vld1q_u8( rk );
++        rk += 16;
++        x = vaesdq_u8( x, k );
++    }
++
++    k = vld1q_u8( rk );                             /* final key just XORed */
++    x = veorq_u8( x, k );
++    vst1q_u8( output, x );                          /* write out */
++
++    return ( 0 );
++}
++
++#endif /* MBEDTLS_AES_C */
++
++
++/*
++ *  [Armv8 Cryptography Extensions]  Multiply in GF(2^128) for GCM
++ */
++
++#if defined(MBEDTLS_GCM_C)
++
++void mbedtls_armv8ce_gcm_mult( unsigned char c[16],
++                               const unsigned char a[16],
++                               const unsigned char b[16] )
++{
++    /* GCM's GF(2^128) polynomial basis is x^128 + x^7 + x^2 + x + 1 */
++    const uint64x2_t base = { 0, 0x86 };            /* note missing LS bit */
++
++    register uint8x16_t vc asm( "v0" );             /* named registers */
++    register uint8x16_t va asm( "v1" );             /* (to avoid conflict) */
++    register uint8x16_t vb asm( "v2" );
++    register uint64x2_t vp asm( "v3" );
++
++    va = vld1q_u8( a );                             /* load inputs */
++    vb = vld1q_u8( b );
++    vp = base;
++
++    asm (
++        "rbit    %1.16b, %1.16b             \n\t"   /* reverse bit order */
++        "rbit    %2.16b, %2.16b             \n\t"
++        "pmull2  %0.1q,  %1.2d,  %2.2d      \n\t"   /* v0 = a.hi * b.hi */
++        "pmull2  v4.1q,  %0.2d,  %3.2d      \n\t"   /* mul v0 by x^64, reduce */
++        "ext     %0.16b, %0.16b, %0.16b, #8 \n\t"
++        "eor     %0.16b, %0.16b, v4.16b     \n\t"
++        "ext     v5.16b, %2.16b, %2.16b, #8 \n\t"   /* (swap hi and lo in b) */
++        "pmull   v4.1q,  %1.1d,  v5.1d      \n\t"   /* v0 ^= a.lo * b.hi */
++        "eor     %0.16b, %0.16b, v4.16b     \n\t"
++        "pmull2  v4.1q,  %1.2d,  v5.2d      \n\t"   /* v0 ^= a.hi * b.lo */
++        "eor     %0.16b, %0.16b, v4.16b     \n\t"
++        "pmull2  v4.1q,  %0.2d,  %3.2d      \n\t"   /* mul v0 by x^64, reduce */
++        "ext     %0.16b, %0.16b, %0.16b, #8 \n\t"
++        "eor     %0.16b, %0.16b, v4.16b     \n\t"
++        "pmull   v4.1q,  %1.1d,  %2.1d      \n\t"   /* v0 ^= a.lo * b.lo */
++        "eor     %0.16b, %0.16b, v4.16b     \n\t"
++        "rbit    %0.16b, %0.16b             \n\t"   /* reverse bits for output */
++        : "=w" (vc)                                 /* q0:      output */
++        : "w" (va), "w" (vb), "w" (vp)              /* q1, q2:  input */
++        : "v4", "v5"                                /* q4, q5:  clobbered */
++    );
++
++    vst1q_u8( c, vc );                              /* write out */
++}
++
++#endif /* MBEDTLS_GCM_C */
++
++#endif /* MBEDTLS_ARMV8CE_AES_C */
+diff -ruNa --binary a/library/CMakeLists.txt b/library/CMakeLists.txt
+--- a/library/CMakeLists.txt	2020-12-10 20:54:15.000000000 +0800
++++ b/library/CMakeLists.txt	2021-03-07 15:06:45.625543309 +0800
+@@ -7,6 +7,7 @@
+     aesni.c
+     arc4.c
+     aria.c
++    armv8ce_aes.c
+     asn1parse.c
+     asn1write.c
+     base64.c
+diff -ruNa --binary a/library/gcm.c b/library/gcm.c
+--- a/library/gcm.c	2020-12-10 20:54:15.000000000 +0800
++++ b/library/gcm.c	2021-03-07 15:06:45.625543309 +0800
+@@ -71,6 +71,10 @@
+ #include "mbedtls/aesni.h"
+ #endif
+ 
++#if defined(MBEDTLS_ARMV8CE_AES_C)
++#include "mbedtls/armv8ce_aes.h"
++#endif
++
+ #if defined(MBEDTLS_SELF_TEST) && defined(MBEDTLS_AES_C)
+ #include "mbedtls/aes.h"
+ #include "mbedtls/platform.h"
+@@ -140,6 +144,12 @@
+     if( ( ret = mbedtls_cipher_update( &ctx->cipher_ctx, h, 16, h, &olen ) ) != 0 )
+         return( ret );
+ 
++#if defined(MBEDTLS_ARMV8CE_AES_C)
++	// we don't do feature testing with ARMv8 cryptography extensions
++    memcpy( ctx ->HL, h, 16 );          // put H at the beginning of buffer
++    return( 0 );                        // that's all we need
++#endif
++
+     /* pack h as two 64-bits ints, big-endian */
+     GET_UINT32_BE( hi, h,  0  );
+     GET_UINT32_BE( lo, h,  4  );
+@@ -248,6 +258,11 @@
+     unsigned char lo, hi, rem;
+     uint64_t zh, zl;
+ 
++#if defined(MBEDTLS_ARMV8CE_AES_C)
++	mbedtls_armv8ce_gcm_mult( output, x, (const unsigned char *) ctx->HL );
++	return;
++#endif
++
+ #if defined(MBEDTLS_AESNI_C) && defined(MBEDTLS_HAVE_X86_64)
+     if( mbedtls_aesni_has_support( MBEDTLS_AESNI_CLMUL ) ) {
+         unsigned char h[16];
+diff -ruNa --binary a/library/Makefile b/library/Makefile
+--- a/library/Makefile	2020-12-10 20:54:15.000000000 +0800
++++ b/library/Makefile	2021-03-07 15:12:49.277078224 +0800
+@@ -65,6 +65,7 @@
+ 
+ OBJS_CRYPTO=	aes.o		aesni.o		arc4.o		\
+ 		aria.o		asn1parse.o	asn1write.o	\
++		armv8ce_aes.o					\
+ 		base64.o	bignum.o	blowfish.o	\
+ 		camellia.o	ccm.o		chacha20.o	\
+ 		chachapoly.o	cipher.o	cipher_wrap.o	\
+diff -ruNa --binary a/library/version_features.c b/library/version_features.c
+--- a/library/version_features.c	2020-12-10 20:54:15.000000000 +0800
++++ b/library/version_features.c	2021-03-07 15:06:45.625543309 +0800
+@@ -583,6 +583,9 @@
+ #if defined(MBEDTLS_AESNI_C)
+     "MBEDTLS_AESNI_C",
+ #endif /* MBEDTLS_AESNI_C */
++#if defined(MBEDTLS_ARMV8CE_AES_C)
++    "MBEDTLS_ARMV8CE_AES_C",
++#endif /* MBEDTLS_ARMV8CE_AES_C */
+ #if defined(MBEDTLS_AES_C)
+     "MBEDTLS_AES_C",
+ #endif /* MBEDTLS_AES_C */
+

--- a/package/libs/mbedtls/Makefile
+++ b/package/libs/mbedtls/Makefile
@@ -22,6 +22,8 @@
 
 PKG_CONFIG_DEPENDS := \
 	CONFIG_LIBMBEDTLS_DEBUG_C \
+	CONFIG_LIBMBEDTLS_HAVE_ARMV8CE_AES \
+	CONFIG_LIBMBEDTLS_HAVE_SSE2 \
 	CONFIG_LIBMBEDTLS_HKDF_C
 
 include $(INCLUDE_DIR)/package.mk
@@ -59,6 +61,34 @@
 
 	 Usually, you don't need this, so don't select this if you're unsure.
 
+config LIBMBEDTLS_HAVE_ARMV8CE_AES
+	depends on PACKAGE_libmbedtls
+	bool
+	default y
+	prompt "Enable use of the ARMv8 Crypto Extensions"
+	depends on aarch64 && !TARGET_bcm27xx && !TARGET_bcm4908
+	help
+	 Use of the ARMv8 Crypto Extensions greatly increase performance
+	 (up to 4x faster on AES-GCM while 10x faster on raw AES).
+
+	 Related instructions should be included in all modern Aarch64
+	 devices, except some wastes like Broadcom.
+	 If you don't sure, say Y here.
+
+config LIBMBEDTLS_HAVE_SSE2
+	depends on PACKAGE_libmbedtls
+	bool
+	default y if !TARGET_x86_legacy && !TARGET_x86_geode
+	prompt "Enable use of x86 SSE2 instructions"
+	depends on x86_64 || i386
+	help
+	 Use of SSE2 instructions greatly increase performance (up to
+	 3x faster) with a minimum (~0.2%, or 23KB) increase in package
+	 size, but it will bring no benefit if your hardware does not
+	 support them, such as Geode GX and LX.  In this case you may
+	 save 23KB by saying yes here.  AMD Geode NX, and Intel
+	 Pentium 4 and above support SSE2.
+
 config LIBMBEDTLS_HKDF_C
 	depends on PACKAGE_libmbedtls
 	bool "Enable the HKDF algorithm (RFC 5869)"
@@ -89,6 +119,9 @@
 
 TARGET_CFLAGS += -ffunction-sections -fdata-sections
 TARGET_CFLAGS := $(filter-out -O%,$(TARGET_CFLAGS))
+ifneq ($(CONFIG_LIBMBEDTLS_HAVE_ARMV8CE_AES),)
+  TARGET_CFLAGS := $(filter-out -march=%,$(TARGET_CFLAGS)) -march=armv8-a+crypto
+endif
 
 CMAKE_OPTIONS += \
 	-DUSE_SHARED_MBEDTLS_LIBRARY:Bool=ON \
@@ -100,6 +133,8 @@
 
 	awk 'BEGIN { rc = 1 } \
 	     /#define MBEDTLS_DEBUG_C/ { $$$$0 = "$(if $(CONFIG_LIBMBEDTLS_DEBUG_C),,// )#define MBEDTLS_DEBUG_C"; rc = 0 } \
+	     /#define MBEDTLS_ARMV8CE_AES_C/ { $$$$0 = "$(if $(CONFIG_LIBMBEDTLS_HAVE_ARMV8CE_AES),,// )#define MBEDTLS_ARMV8CE_AES_C"; rc = 0 } \
+	     /#define MBEDTLS_HAVE_SSE2/ { $$$$0 = "$(if $(CONFIG_LIBMBEDTLS_HAVE_SSE2),,// )#define MBEDTLS_HAVE_SSE2"; rc = 0 } \
 	     { print } \
 	     END { exit(rc) }' $(PKG_BUILD_DIR)/include/mbedtls/config.h \
 	     >$(PKG_BUILD_DIR)/include/mbedtls/config.h.new && \

--- a/package/network/config/firewall/files/firewall.config
+++ b/package/network/config/firewall/files/firewall.config
@@ -1,208 +1,49 @@
+
 config defaults
-	option syn_flood	1
-	option input		ACCEPT
-	option output		ACCEPT
-	option forward		REJECT
-# Uncomment this line to disable ipv6 rules
-#	option disable_ipv6	1
+	option synflood_protect '1'
+	option input 'DROP'
+	option output 'ACCEPT'
+	option forward 'DROP'
 
 config zone
-	option name		lan
-	list   network		'lan'
-	option input		ACCEPT
-	option output		ACCEPT
-	option forward		ACCEPT
+	option name 'lan'
+	option network 'lan'
+	option input 'ACCEPT'
+	option output 'ACCEPT'
+	option forward 'ACCEPT'
 
 config zone
-	option name		wan
-	list   network		'wan'
-	list   network		'wan6'
-	option input		REJECT
-	option output		ACCEPT
-	option forward		REJECT
-	option masq		1
-	option mtu_fix		1
+	option name 'wan'
+	list network 'wan'
+	option input 'DROP'
+	option output 'ACCEPT'
+	option forward 'DROP'
+	option masq '1'
+	option mtu_fix '1'
+	option fullcone '1'
 
 config forwarding
-	option src		lan
-	option dest		wan
-
-# We need to accept udp packets on port 68,
-# see https://dev.openwrt.org/ticket/4108
-config rule
-	option name		Allow-DHCP-Renew
-	option src		wan
-	option proto		udp
-	option dest_port	68
-	option target		ACCEPT
-	option family		ipv4
-
-# Allow IPv4 ping
-config rule
-	option name		Allow-Ping
-	option src		wan
-	option proto		icmp
-	option icmp_type	echo-request
-	option family		ipv4
-	option target		ACCEPT
+	option dest 'wan'
+	option src 'lan'
 
 config rule
-	option name		Allow-IGMP
-	option src		wan
-	option proto		igmp
-	option family		ipv4
-	option target		ACCEPT
+	option name 'Allow-DHCPv6'
+	option family 'ipv6'
+	list proto 'udp'
+	option src 'wan'
+	list src_ip 'fc00::/6'
+	list dest_ip 'fc00::/6'
+	option dest_port '546'
+	option target 'ACCEPT'
+
+config rule
+	option name 'Allow-MLD'
+	option family 'ipv6'
+	list proto 'icmp'
+	option src 'wan'
+	list src_ip 'fe80::/10'
+	option target 'ACCEPT'
 
-# Allow DHCPv6 replies
-# see https://dev.openwrt.org/ticket/10381
-config rule
-	option name		Allow-DHCPv6
-	option src		wan
-	option proto		udp
-	option src_ip		fc00::/6
-	option dest_ip		fc00::/6
-	option dest_port	546
-	option family		ipv6
-	option target		ACCEPT
-
-config rule
-	option name		Allow-MLD
-	option src		wan
-	option proto		icmp
-	option src_ip		fe80::/10
-	list icmp_type		'130/0'
-	list icmp_type		'131/0'
-	list icmp_type		'132/0'
-	list icmp_type		'143/0'
-	option family		ipv6
-	option target		ACCEPT
-
-# Allow essential incoming IPv6 ICMP traffic
-config rule
-	option name		Allow-ICMPv6-Input
-	option src		wan
-	option proto	icmp
-	list icmp_type		echo-request
-	list icmp_type		echo-reply
-	list icmp_type		destination-unreachable
-	list icmp_type		packet-too-big
-	list icmp_type		time-exceeded
-	list icmp_type		bad-header
-	list icmp_type		unknown-header-type
-	list icmp_type		router-solicitation
-	list icmp_type		neighbour-solicitation
-	list icmp_type		router-advertisement
-	list icmp_type		neighbour-advertisement
-	option limit		1000/sec
-	option family		ipv6
-	option target		ACCEPT
-
-# Allow essential forwarded IPv6 ICMP traffic
-config rule
-	option name		Allow-ICMPv6-Forward
-	option src		wan
-	option dest		*
-	option proto		icmp
-	list icmp_type		echo-request
-	list icmp_type		echo-reply
-	list icmp_type		destination-unreachable
-	list icmp_type		packet-too-big
-	list icmp_type		time-exceeded
-	list icmp_type		bad-header
-	list icmp_type		unknown-header-type
-	option limit		1000/sec
-	option family		ipv6
-	option target		ACCEPT
-
-config rule
-	option name		Allow-IPSec-ESP
-	option src		wan
-	option dest		lan
-	option proto		esp
-	option target		ACCEPT
-
-config rule
-	option name		Allow-ISAKMP
-	option src		wan
-	option dest		lan
-	option dest_port	500
-	option proto		udp
-	option target		ACCEPT
-
-# allow interoperability with traceroute classic
-# note that traceroute uses a fixed port range, and depends on getting
-# back ICMP Unreachables.  if we're operating in DROP mode, it won't
-# work so we explicitly REJECT packets on these ports.
-config rule
-	option name		Support-UDP-Traceroute
-	option src		wan
-	option dest_port	33434:33689
-	option proto		udp
-	option family		ipv4
-	option target		REJECT
-	option enabled		false
-
-# include a file with users custom iptables rules
 config include
-	option path /etc/firewall.user
-
+	option path '/etc/firewall.user'
 
-### EXAMPLE CONFIG SECTIONS
-# do not allow a specific ip to access wan
-#config rule
-#	option src		lan
-#	option src_ip	192.168.45.2
-#	option dest		wan
-#	option proto	tcp
-#	option target	REJECT
-
-# block a specific mac on wan
-#config rule
-#	option dest		wan
-#	option src_mac	00:11:22:33:44:66
-#	option target	REJECT
-
-# block incoming ICMP traffic on a zone
-#config rule
-#	option src		lan
-#	option proto	ICMP
-#	option target	DROP
-
-# port redirect port coming in on wan to lan
-#config redirect
-#	option src			wan
-#	option src_dport	80
-#	option dest			lan
-#	option dest_ip		192.168.16.235
-#	option dest_port	80
-#	option proto		tcp
-
-# port redirect of remapped ssh port (22001) on wan
-#config redirect
-#	option src		wan
-#	option src_dport	22001
-#	option dest		lan
-#	option dest_port	22
-#	option proto		tcp
-
-### FULL CONFIG SECTIONS
-#config rule
-#	option src		lan
-#	option src_ip	192.168.45.2
-#	option src_mac	00:11:22:33:44:55
-#	option src_port	80
-#	option dest		wan
-#	option dest_ip	194.25.2.129
-#	option dest_port	120
-#	option proto	tcp
-#	option target	REJECT
-
-#config redirect
-#	option src		lan
-#	option src_ip	192.168.45.2
-#	option src_mac	00:11:22:33:44:55
-#	option src_port		1024
-#	option src_dport	80
-#	option dest_ip	194.25.2.129
-#	option dest_port	120
-#	option proto	tcp

--- /dev/null
+++ b/package/network/config/firewall/patches/fullconenat.patch
@@ -0,0 +1,40 @@
+--- a/options.h
++++ b/options.h
+@@ -341,6 +341,8 @@ struct fw3_zone
+ 	struct list_head masq_src;
+ 	struct list_head masq_dest;
+ 
++	bool fullcone;
++
+ 	bool mtu_fix;
+ 
+ 	struct list_head cthelpers;
+--- a/zones.c
++++ b/zones.c
+@@ -77,6 +77,8 @@ const struct fw3_option fw3_zone_opts[]
+ 	FW3_LIST("masq_src",           network,  zone,     masq_src),
+ 	FW3_LIST("masq_dest",          network,  zone,     masq_dest),
+ 
++	FW3_OPT("fullcone",            bool,     zone,     fullcone),
++
+ 	FW3_OPT("extra",               string,   zone,     extra_src),
+ 	FW3_OPT("extra_src",           string,   zone,     extra_src),
+ 	FW3_OPT("extra_dest",          string,   zone,     extra_dest),
+@@ -709,7 +711,16 @@ print_zone_rule(struct fw3_ipt_handle *h
+ 				     (mdest = next_addr(mdest, &zone->masq_dest,
+ 					                    handle->family, false)) || first_dest;
+ 				     first_dest = false)
+-				{
++				if (zone->fullcone && (access("/usr/lib/iptables/libipt_FULLCONENAT.so", 0) == 0)) {
++					r = fw3_ipt_rule_new(handle);
++					fw3_ipt_rule_src_dest(r, msrc, mdest);
++					fw3_ipt_rule_target(r, "FULLCONENAT");
++					fw3_ipt_rule_append(r, "zone_%s_postrouting", zone->name);
++					r = fw3_ipt_rule_new(handle);
++					fw3_ipt_rule_src_dest(r, msrc, mdest);
++					fw3_ipt_rule_target(r, "FULLCONENAT");
++					fw3_ipt_rule_append(r, "zone_%s_prerouting", zone->name);
++				} else {
+ 					r = fw3_ipt_rule_new(handle);
+ 					fw3_ipt_rule_src_dest(r, msrc, mdest);
+ 					fw3_ipt_rule_target(r, "MASQUERADE");

--- a/package/network/services/dnsmasq/files/dhcp.conf
+++ b/package/network/services/dnsmasq/files/dhcp.conf
@@ -1,33 +1,25 @@
+
 config dnsmasq
-	option domainneeded	1
-	option boguspriv	1
-	option filterwin2k	0  # enable for dial on demand
-	option localise_queries	1
-	option rebind_protection 1  # disable if upstream must serve RFC1918 addresses
-	option rebind_localhost 1  # enable for RBL checking and similar services
-	#list rebind_domain example.lan  # whitelist RFC1918 responses for domains
-	option local	'/lan/'
-	option domain	'lan'
-	option expandhosts	1
-	option nonegcache	0
-	option authoritative	1
-	option readethers	1
-	option leasefile	'/tmp/dhcp.leases'
-	option resolvfile	'/tmp/resolv.conf.d/resolv.conf.auto'
-	#list server		'/mycompany.local/1.2.3.4'
-	option nonwildcard	1 # bind to & keep track of interfaces
-	#list interface		br-lan
-	#list notinterface	lo
-	#list bogusnxdomain     '64.94.110.11'
-	option localservice	1  # disable to allow DNS requests from non-local subnets
-	option ednspacket_max	1232
+	option domainneeded '1'
+	option authoritative '1'
+	option local '/lan/'
+	option domain 'lan'
+	option rebind_protection '1'
+	option rebind_localhost '1'
+	option localservice '0'
+	option nonwildcard '0'
+	option readethers '1'
+	option leasefile '/tmp/dhcp.leases'
+	option sequential_ip '1'
+	option localise_queries '1'
+	option expandhosts '1'
+	option ednspacket_max '1232'
+	option cachesize '1000'
 
-config dhcp lan
-	option interface	lan
-	option start 	100
-	option limit	150
-	option leasetime	12h
+config dhcp 'lan'
+	option interface 'lan'
+	option start '10'
+	option limit '150'
+	option leasetime '2h'
+	option force '1'
 
-config dhcp wan
-	option interface	wan
-	option ignore	1

--- a/package/network/services/odhcpd/files/odhcpd.defaults
+++ b/package/network/services/odhcpd/files/odhcpd.defaults
@@ -11,41 +11,20 @@
 json_select ..
 json_select ..
 
-ODHCPDONLY=0
-V4MODE=disabled
-V6MODE=disabled
-
-[ -e /usr/sbin/dnsmasq ] || ODHCPDONLY=1
-
 case "$protocol" in
 # only enable server mode on statically addressed lan ports
-"static")
-	V4MODE=server
-	[ -e /proc/sys/net/ipv6 ] && V6MODE=server
-	;;
+"static") [ -e /proc/sys/net/ipv6 ] && MODE=server || MODE=disabled ;;
+*) MODE=disabled ;;
 esac
 
-uci get dhcp.lan 1>/dev/null 2>/dev/null || {
-uci batch <<EOF
-set dhcp.lan=dhcp
-set dhcp.lan.interface='lan'
-set dhcp.lan.start='100'
-set dhcp.lan.limit='150'
-set dhcp.lan.leasetime='12h'
-set dhcp.lan.domain='lan'
-EOF
-}
-
 uci batch <<EOF
 set dhcp.odhcpd=odhcpd
-set dhcp.odhcpd.maindhcp=$ODHCPDONLY
+set dhcp.odhcpd.maindhcp=0
 set dhcp.odhcpd.leasefile=/tmp/hosts/odhcpd
 set dhcp.odhcpd.leasetrigger=/usr/sbin/odhcpd-update
 set dhcp.odhcpd.loglevel=4
-set dhcp.lan.dhcpv4=$V4MODE
-set dhcp.lan.dhcpv6=$V6MODE
-set dhcp.lan.ra=$V6MODE
-set dhcp.lan.ra_slaac=1
+set dhcp.lan.ra=$MODE
+set dhcp.lan.dhcpv6=$MODE
 add_list dhcp.lan.ra_flags=managed-config
 add_list dhcp.lan.ra_flags=other-config
 commit dhcp

--- a/package/network/services/uhttpd/files/uhttpd.config
+++ b/package/network/services/uhttpd/files/uhttpd.config
@@ -1,143 +1,31 @@
-# Server configuration
-config uhttpd main
 
-	# HTTP listen addresses, multiple allowed
-	list listen_http	0.0.0.0:80
-	list listen_http	[::]:80
+config uhttpd 'main'
+	list listen_http '0.0.0.0:80'
+	list listen_http '[::]:80'
+	list listen_https '0.0.0.0:443'
+	list listen_https '[::]:443'
+	option redirect_https '0'
+	option home '/www'
+	option rfc1918_filter '1'
+	option max_requests '3'
+	option max_connections '100'
+	option cert '/etc/uhttpd.crt'
+	option key '/etc/uhttpd.key'
+	option cgi_prefix '/cgi-bin'
+	list lua_prefix '/cgi-bin/luci=/usr/lib/lua/luci/sgi/uhttpd.lua'
+	option script_timeout '60'
+	option network_timeout '30'
+	option http_keepalive '20'
+	option tcp_keepalive '1'
+	option ubus_prefix '/ubus'
+
+config cert 'defaults'
+	option days '730'
+	option key_type 'ec'
+	option bits '2048'
+	option ec_curve 'P-256'
+	option country 'ZZ'
+	option state 'Somewhere'
+	option location 'Unknown'
+	option commonname '%D'
 
-	# HTTPS listen addresses, multiple allowed
-	list listen_https	0.0.0.0:443
-	list listen_https	[::]:443
-
-	# Redirect HTTP requests to HTTPS if possible
-	option redirect_https	0
-
-	# Server document root
-	option home		/www
-
-	# Reject requests from RFC1918 IP addresses
-	# directed to the servers public IP(s).
-	# This is a DNS rebinding countermeasure.
-	option rfc1918_filter 1
-
-	# Maximum number of concurrent requests.
-	# If this number is exceeded, further requests are
-	# queued until the number of running requests drops
-	# below the limit again.
-	option max_requests 3
-
-	# Maximum number of concurrent connections.
-	# If this number is exceeded, further TCP connection
-	# attempts are queued until the number of active
-	# connections drops below the limit again.
-	option max_connections 100
-
-	# Certificate and private key for HTTPS.
-	# If no listen_https addresses are given,
-	# the key options are ignored.
-	option cert		/etc/uhttpd.crt
-	option key		/etc/uhttpd.key
-
-	# CGI url prefix, will be searched in docroot.
-	# Default is /cgi-bin
-	option cgi_prefix	/cgi-bin
-
-	# List of extension->interpreter mappings.
-	# Files with an associated interpreter can
-	# be called outside of the CGI prefix and do
-	# not need to be executable.
-#	list interpreter	".php=/usr/bin/php-cgi"
-#	list interpreter	".cgi=/usr/bin/perl"
-
-	# List of prefix->Lua handler mappings.
-	# Any request to an URL beneath the prefix
-	# will be dispatched to the associated Lua
-	# handler script. Lua support is disabled when
-	# no handler mappings are specified. Lua prefix
-	# matches have precedence over the CGI prefix.
-	list lua_prefix		"/cgi-bin/luci=/usr/lib/lua/luci/sgi/uhttpd.lua"
-
-	# Specify the ubus-rpc prefix and socket path.
-#	option ubus_prefix	/ubus
-#	option ubus_socket	/var/run/ubus/ubus.sock
-
-	# CGI/Lua timeout, if the called script does not
-	# write data within the given amount of seconds,
-	# the server will terminate the request with
-	# 504 Gateway Timeout response.
-	option script_timeout	60
-
-	# Network timeout, if the current connection is
-	# blocked for the specified amount of seconds,
-	# the server will terminate the associated
-	# request process.
-	option network_timeout	30
-
-	# HTTP Keep-Alive, specifies the timeout for persistent
-	# HTTP/1.1 connections. Setting this to 0 will disable
-	# persistent HTTP connections.
-	option http_keepalive	20
-
-	# TCP Keep-Alive, send periodic keep-alive probes
-	# over established connections to detect dead peers.
-	# The value is given in seconds to specify the
-	# interval between subsequent probes.
-	# Setting this to 0 will disable TCP keep-alive.
-	option tcp_keepalive	1
-
-	# Basic auth realm, defaults to local hostname
-#	option realm	OpenWrt
-
-	# Configuration file in busybox httpd format
-#	option config	/etc/httpd.conf
-
-	# Do not follow symlinks that point outside of the
-	# home directory.
-#	option no_symlinks	0
-
-	# Do not produce directory listings but send 403
-	# instead if a client requests an url pointing to
-	# a directory without any index file.
-#	option no_dirlists	0
-
-	# Do not authenticate any ubus-rpc requests against
-	# the ubus session/access procedure.
-	# This is dangerous and should be always left off
-	# except for development and debug purposes!
-#	option no_ubusauth	0
-
-	# For this instance of uhttpd use the listed httpauth
-	# sections to require Basic auth to the specified
-	# resources.
-#	list httpauth prefix_user
-
-
-# Defaults for automatic certificate and key generation
-config cert defaults
-
-	# Validity time
-	option days		730
-
-	# key type: rsa or ec
-	option key_type		ec
-
-	# RSA key size
-	option bits		2048
-
-	# EC curve name
-	# Curve names vary between px5g-{wolfssl,mbedtls} and openssl
-	# P-256 or P-384 are guaranteed to work
-	option ec_curve		P-256
-
-	# Location
-	option country		ZZ
-	option state		Somewhere
-	option location		Unknown
-
-	# Common name
-	option commonname	'%D'
-
-# config httpauth prefix_user
-#	option prefix /protected/url/path
-#	option username user
-#	option password 'plaintext_or_md5_or_$p$user_for_system_user'

--- a/package/utils/busybox/config/networking/Config.in
+++ b/package/utils/busybox/config/networking/Config.in
@@ -775,6 +775,20 @@
 	default BUSYBOX_DEFAULT_FEATURE_NSLOOKUP_LONG_OPTIONS
 	depends on BUSYBOX_CONFIG_FEATURE_NSLOOKUP_BIG && BUSYBOX_CONFIG_LONG_OPTS
 
+config BUSYBOX_CONFIG_NSLOOKUP_OPENWRT
+	bool "nslookup_openwrt"
+	depends on !BUSYBOX_CONFIG_NSLOOKUP
+	default BUSYBOX_DEFAULT_NSLOOKUP_OPENWRT
+	help
+	  nslookup is a tool to query Internet name servers (LEDE flavor).
+
+config BUSYBOX_CONFIG_FEATURE_NSLOOKUP_OPENWRT_LONG_OPTIONS
+       bool "Enable long options"
+       default BUSYBOX_DEFAULT_FEATURE_NSLOOKUP_OPENWRT_LONG_OPTIONS
+       depends on BUSYBOX_CONFIG_NSLOOKUP_OPENWRT && BUSYBOX_CONFIG_LONG_OPTS
+       help
+         Support long options for the nslookup applet.
+
 config BUSYBOX_CONFIG_NTPD
 	bool "ntpd (22 kb)"
 	default BUSYBOX_DEFAULT_NTPD

--- /dev/null
+++ b/package/utils/busybox/patches/540-nslookup-mention-QUERY_TYPE-SRV.patch
@@ -1,30 +0,0 @@
-From a0136f24f788e8bfc4ab74a647b27e115a25d9fb Mon Sep 17 00:00:00 2001
-From: Paul Spooren <mail@aparcar.org>
-Date: Wed, 19 May 2021 00:55:21 +0200
-Subject: [PATCH] nslookup: mention QUERY_TYPE SRV
-
-SRV lookups are supported since "6b4960155 nslookup: implement support
-for SRV records" and should therefore be mentioned as a possible
-QUERY_TYPE in the help message.
-
-Signed-off-by: Paul Spooren <mail@aparcar.org>
----
- networking/nslookup.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
-diff --git a/networking/nslookup.c b/networking/nslookup.c
-index dda22de0e..2ae8d391c 100644
---- a/networking/nslookup.c
-+++ b/networking/nslookup.c
-@@ -25,7 +25,7 @@
- //usage:#define nslookup_full_usage "\n\n"
- //usage:       "Query DNS about HOST"
- //usage:       IF_FEATURE_NSLOOKUP_BIG("\n")
--//usage:       IF_FEATURE_NSLOOKUP_BIG("\nQUERY_TYPE: soa,ns,a,"IF_FEATURE_IPV6("aaaa,")"cname,mx,txt,ptr,any")
-+//usage:       IF_FEATURE_NSLOOKUP_BIG("\nQUERY_TYPE: soa,ns,a,"IF_FEATURE_IPV6("aaaa,")"cname,mx,txt,ptr,srv,any")
- //usage:#define nslookup_example_usage
- //usage:       "$ nslookup localhost\n"
- //usage:       "Server:     default\n"
--- 
-2.30.2
-

--- /dev/null
+++ b/package/utils/busybox/patches/230-add_nslookup_lede.patch
@@ -0,0 +1,971 @@
+From ab0f8bb80527928f513297ab93e3ec8c8b48dd50 Mon Sep 17 00:00:00 2001
+From: Jo-Philipp Wich <jo@mein.io>
+Date: Tue, 14 Mar 2017 22:21:34 +0100
+Subject: [PATCH] networking: add LEDE nslookup applet
+
+Add a new LEDE nslookup applet which is compatible with musl libc
+and providing more features like ability to specify query type.
+
+In contrast to busybox' builtin nslookup applet, this variant does
+not rely on libc resolver internals but uses explicit send logic
+and the libresolv primitives to parse received DNS responses.
+
+Signed-off-by: Jo-Philipp Wich <jo@mein.io>
+---
+ Makefile.flags             |   6 +
+ networking/nslookup_lede.c | 915 +++++++++++++++++++++++++++++++++++++++++++++
+ 2 files changed, 921 insertions(+)
+ create mode 100644 networking/nslookup_lede.c
+
+--- a/Makefile.flags
++++ b/Makefile.flags
+@@ -158,6 +158,12 @@ endif
+ # libm may be needed for dc, awk, ntpd
+ # librt may be needed for clock_gettime()
+ 
++# nslookup_lede might need the resolv library
++RESOLV_AVAILABLE := $(shell echo 'int main(void){res_init();return 0;}' >resolvtest.c; $(CC) $(CFLAGS) -include resolv.h -lresolv -o /dev/null resolvtest.c >/dev/null 2>&1 && echo "y"; rm resolvtest.c)
++ifeq ($(RESOLV_AVAILABLE),y)
++LDLIBS += resolv
++endif
++
+ # libpam may use libpthread, libdl and/or libaudit.
+ # On some platforms that requires an explicit -lpthread, -ldl, -laudit.
+ # However, on *other platforms* it fails when some of those flags
+--- /dev/null
++++ b/networking/nslookup_lede.c
+@@ -0,0 +1,934 @@
++/*
++ * nslookup_lede - musl compatible replacement for busybox nslookup
++ *
++ * Copyright (C) 2017 Jo-Philipp Wich <jo@mein.io>
++ *
++ * Permission to use, copy, modify, and/or distribute this software for any
++ * purpose with or without fee is hereby granted, provided that the above
++ * copyright notice and this permission notice appear in all copies.
++ *
++ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
++ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
++ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
++ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
++ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
++ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
++ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
++ */
++
++//config:config NSLOOKUP_OPENWRT
++//config:	bool "nslookup_openwrt"
++//config:	depends on !NSLOOKUP
++//config:	default y
++//config:	help
++//config:	  nslookup is a tool to query Internet name servers (LEDE flavor).
++//config:
++//config:config FEATURE_NSLOOKUP_OPENWRT_LONG_OPTIONS
++//config:       bool "Enable long options"
++//config:       default y
++//config:       depends on NSLOOKUP_OPENWRT && LONG_OPTS
++//config:       help
++//config:         Support long options for the nslookup applet.
++
++//applet:IF_NSLOOKUP_OPENWRT(APPLET(nslookup, BB_DIR_USR_BIN, BB_SUID_DROP))
++
++//kbuild:lib-$(CONFIG_NSLOOKUP_OPENWRT) += nslookup_lede.o
++
++//usage:#define nslookup_lede_trivial_usage
++//usage:       "[HOST] [SERVER]"
++//usage:#define nslookup_lede_full_usage "\n\n"
++//usage:       "Query the nameserver for the IP address of the given HOST\n"
++//usage:       "optionally using a specified DNS server"
++//usage:
++//usage:#define nslookup_lede_example_usage
++//usage:       "$ nslookup localhost\n"
++//usage:       "Server:     default\n"
++//usage:       "Address:    default\n"
++//usage:       "\n"
++//usage:       "Name:       debian\n"
++//usage:       "Address:    127.0.0.1\n"
++
++#include <stdio.h>
++#include <resolv.h>
++#include <string.h>
++#include <errno.h>
++#include <time.h>
++#include <poll.h>
++#include <unistd.h>
++#include <stdlib.h>
++#include <sys/socket.h>
++#include <arpa/inet.h>
++#include <net/if.h>
++#include <netdb.h>
++
++#include "libbb.h"
++
++struct ns {
++	const char *name;
++	len_and_sockaddr addr;
++	int failures;
++	int replies;
++};
++
++struct query {
++	const char *name;
++	size_t qlen, rlen;
++	unsigned char query[512], reply[512];
++	unsigned long latency;
++	int rcode, n_ns;
++};
++
++static struct {
++	int type;
++	const char *name;
++} qtypes[] = {
++	{ ns_t_soa,   "SOA"   },
++	{ ns_t_ns,    "NS"    },
++	{ ns_t_a,     "A"     },
++#if ENABLE_FEATURE_IPV6
++	{ ns_t_aaaa,  "AAAA"  },
++#endif
++	{ ns_t_cname, "CNAME" },
++	{ ns_t_mx,    "MX"    },
++	{ ns_t_txt,   "TXT"   },
++	{ ns_t_srv,   "SRV"   },
++	{ ns_t_ptr,   "PTR"   },
++	{ ns_t_any,   "ANY"   },
++	{ }
++};
++
++static const char *rcodes[] = {
++	"NOERROR",
++	"FORMERR",
++	"SERVFAIL",
++	"NXDOMAIN",
++	"NOTIMP",
++	"REFUSED",
++	"YXDOMAIN",
++	"YXRRSET",
++	"NXRRSET",
++	"NOTAUTH",
++	"NOTZONE",
++	"RESERVED11",
++	"RESERVED12",
++	"RESERVED13",
++	"RESERVED14",
++	"RESERVED15",
++	"BADVERS"
++};
++
++static unsigned int default_port = 53;
++static unsigned int default_retry = 2;
++static unsigned int default_timeout = 5;
++
++
++static int parse_reply(const unsigned char *msg, size_t len, int *bb_style_counter)
++{
++	ns_msg handle;
++	ns_rr rr;
++	int i, n, rdlen;
++	const char *format = NULL;
++	char astr[INET6_ADDRSTRLEN], dname[MAXDNAME];
++	const unsigned char *cp;
++
++	if (ns_initparse(msg, len, &handle) != 0) {
++		//fprintf(stderr, "Unable to parse reply: %s\n", strerror(errno));
++		return -1;
++	}
++
++	for (i = 0; i < ns_msg_count(handle, ns_s_an); i++) {
++		if (ns_parserr(&handle, ns_s_an, i, &rr) != 0) {
++			//fprintf(stderr, "Unable to parse resource record: %s\n", strerror(errno));
++			return -1;
++		}
++
++		if (bb_style_counter && *bb_style_counter == 1)
++			printf("Name:      %s\n", ns_rr_name(rr));
++
++		rdlen = ns_rr_rdlen(rr);
++
++		switch (ns_rr_type(rr))
++		{
++		case ns_t_a:
++			if (rdlen != 4) {
++				//fprintf(stderr, "Unexpected A record length\n");
++				return -1;
++			}
++			inet_ntop(AF_INET, ns_rr_rdata(rr), astr, sizeof(astr));
++			if (bb_style_counter)
++				printf("Address %d: %s\n", (*bb_style_counter)++, astr);
++			else
++				printf("Name:\t%s\nAddress: %s\n", ns_rr_name(rr), astr);
++			break;
++
++#if ENABLE_FEATURE_IPV6
++		case ns_t_aaaa:
++			if (rdlen != 16) {
++				//fprintf(stderr, "Unexpected AAAA record length\n");
++				return -1;
++			}
++			inet_ntop(AF_INET6, ns_rr_rdata(rr), astr, sizeof(astr));
++			if (bb_style_counter)
++				printf("Address %d: %s\n", (*bb_style_counter)++, astr);
++			else
++				printf("%s\thas AAAA address %s\n", ns_rr_name(rr), astr);
++			break;
++#endif
++
++		case ns_t_ns:
++			if (!format)
++				format = "%s\tnameserver = %s\n";
++			/* fall through */
++
++		case ns_t_cname:
++			if (!format)
++				format = "%s\tcanonical name = %s\n";
++			/* fall through */
++
++		case ns_t_ptr:
++			if (!format)
++				format = "%s\tname = %s\n";
++			if (ns_name_uncompress(ns_msg_base(handle), ns_msg_end(handle),
++				ns_rr_rdata(rr), dname, sizeof(dname)) < 0) {
++				//fprintf(stderr, "Unable to uncompress domain: %s\n", strerror(errno));
++				return -1;
++			}
++			printf(format, ns_rr_name(rr), dname);
++			break;
++
++		case ns_t_mx:
++			if (rdlen < 2) {
++				fprintf(stderr, "MX record too short\n");
++				return -1;
++			}
++			n = ns_get16(ns_rr_rdata(rr));
++			if (ns_name_uncompress(ns_msg_base(handle), ns_msg_end(handle),
++				ns_rr_rdata(rr) + 2, dname, sizeof(dname)) < 0) {
++				//fprintf(stderr, "Cannot uncompress MX domain: %s\n", strerror(errno));
++				return -1;
++			}
++			printf("%s\tmail exchanger = %d %s\n", ns_rr_name(rr), n, dname);
++			break;
++
++		case ns_t_txt:
++			if (rdlen < 1) {
++				//fprintf(stderr, "TXT record too short\n");
++				return -1;
++			}
++			n = *(unsigned char *)ns_rr_rdata(rr);
++			if (n > 0) {
++				memset(dname, 0, sizeof(dname));
++				memcpy(dname, ns_rr_rdata(rr) + 1, n);
++				printf("%s\ttext = \"%s\"\n", ns_rr_name(rr), dname);
++			}
++			break;
++
++		case ns_t_srv:
++			if (rdlen < 6) {
++				//printf("SRV record too short\n");
++				return -1;
++			}
++
++			cp = ns_rr_rdata(rr);
++			n = ns_name_uncompress(ns_msg_base(handle), ns_msg_end(handle),
++			                       cp + 6, dname, sizeof(dname));
++
++			if (n < 0) {
++				//printf("Unable to uncompress domain: %s\n", strerror(errno));
++				return -1;
++			}
++
++			printf("%s\tservice = %hu %hu %hu %s\n", ns_rr_name(rr),
++				ns_get16(cp), ns_get16(cp + 2), ns_get16(cp + 4), dname);
++			break;
++
++		case ns_t_soa:
++			if (rdlen < 20) {
++				//fprintf(stderr, "SOA record too short\n");
++				return -1;
++			}
++
++			printf("%s\n", ns_rr_name(rr));
++
++			cp = ns_rr_rdata(rr);
++			n = ns_name_uncompress(ns_msg_base(handle), ns_msg_end(handle),
++			                       cp, dname, sizeof(dname));
++
++			if (n < 0) {
++				//fprintf(stderr, "Unable to uncompress domain: %s\n", strerror(errno));
++				return -1;
++			}
++
++			printf("\torigin = %s\n", dname);
++			cp += n;
++
++			n = ns_name_uncompress(ns_msg_base(handle), ns_msg_end(handle),
++			                       cp, dname, sizeof(dname));
++
++			if (n < 0) {
++				//fprintf(stderr, "Unable to uncompress domain: %s\n", strerror(errno));
++				return -1;
++			}
++
++			printf("\tmail addr = %s\n", dname);
++			cp += n;
++
++			printf("\tserial = %lu\n", ns_get32(cp));
++			cp += 4;
++
++			printf("\trefresh = %lu\n", ns_get32(cp));
++			cp += 4;
++
++			printf("\tretry = %lu\n", ns_get32(cp));
++			cp += 4;
++
++			printf("\texpire = %lu\n", ns_get32(cp));
++			cp += 4;
++
++			printf("\tminimum = %lu\n", ns_get32(cp));
++			break;
++
++		default:
++			break;
++		}
++	}
++
++	return i;
++}
++
++static int parse_nsaddr(const char *addrstr, len_and_sockaddr *lsa)
++{
++	char *eptr, *hash, ifname[IFNAMSIZ];
++	unsigned int port = default_port;
++	unsigned int scope = 0;
++
++	hash = strchr(addrstr, '#');
++
++	if (hash) {
++		*hash++ = '\0';
++		port = strtoul(hash, &eptr, 10);
++
++		if (eptr == hash || *eptr != '\0' || port > 65535) {
++			errno = EINVAL;
++			return -1;
++		}
++	}
++
++	hash = strchr(addrstr, '%');
++
++	if (hash) {
++		for (eptr = ++hash; *eptr != '\0' && *eptr != '#'; eptr++) {
++			if ((eptr - hash) >= IFNAMSIZ) {
++				errno = ENODEV;
++				return -1;
++			}
++
++			ifname[eptr - hash] = *eptr;
++		}
++
++		ifname[eptr - hash] = '\0';
++		scope = if_nametoindex(ifname);
++
++		if (scope == 0) {
++			errno = ENODEV;
++			return -1;
++		}
++	}
++
++#if ENABLE_FEATURE_IPV6
++	if (inet_pton(AF_INET6, addrstr, &lsa->u.sin6.sin6_addr)) {
++		lsa->u.sin6.sin6_family = AF_INET6;
++		lsa->u.sin6.sin6_port = htons(port);
++		lsa->u.sin6.sin6_scope_id = scope;
++		lsa->len = sizeof(lsa->u.sin6);
++		return 0;
++	}
++#endif
++
++	if (!scope && inet_pton(AF_INET, addrstr, &lsa->u.sin.sin_addr)) {
++		lsa->u.sin.sin_family = AF_INET;
++		lsa->u.sin.sin_port = htons(port);
++		lsa->len = sizeof(lsa->u.sin);
++		return 0;
++	}
++
++	errno = EINVAL;
++	return -1;
++}
++
++static char *make_ptr(const char *addrstr)
++{
++	const char *hexdigit = "0123456789abcdef";
++	static char ptrstr[73];
++	unsigned char addr[16];
++	char *ptr = ptrstr;
++	int i;
++
++	if (inet_pton(AF_INET6, addrstr, addr)) {
++		if (memcmp(addr, "\0\0\0\0\0\0\0\0\0\0\xff\xff", 12) != 0) {
++			for (i = 0; i < 16; i++) {
++				*ptr++ = hexdigit[(unsigned char)addr[15 - i] & 0xf];
++				*ptr++ = '.';
++				*ptr++ = hexdigit[(unsigned char)addr[15 - i] >> 4];
++				*ptr++ = '.';
++			}
++			strcpy(ptr, "ip6.arpa");
++		}
++		else {
++			sprintf(ptr, "%u.%u.%u.%u.in-addr.arpa",
++			        addr[15], addr[14], addr[13], addr[12]);
++		}
++
++		return ptrstr;
++	}
++
++	if (inet_pton(AF_INET, addrstr, addr)) {
++		sprintf(ptr, "%u.%u.%u.%u.in-addr.arpa",
++		        addr[3], addr[2], addr[1], addr[0]);
++		return ptrstr;
++	}
++
++	return NULL;
++}
++
++static unsigned long mtime(void)
++{
++	struct timespec ts;
++	clock_gettime(CLOCK_REALTIME, &ts);
++	return (unsigned long)ts.tv_sec * 1000 + ts.tv_nsec / 1000000;
++}
++
++#if ENABLE_FEATURE_IPV6
++static void to_v4_mapped(len_and_sockaddr *a)
++{
++	if (a->u.sa.sa_family != AF_INET)
++		return;
++
++	memcpy(a->u.sin6.sin6_addr.s6_addr + 12,
++	       &a->u.sin.sin_addr, 4);
++
++	memcpy(a->u.sin6.sin6_addr.s6_addr,
++	       "\0\0\0\0\0\0\0\0\0\0\xff\xff", 12);
++
++	a->u.sin6.sin6_family = AF_INET6;
++	a->u.sin6.sin6_flowinfo = 0;
++	a->u.sin6.sin6_scope_id = 0;
++	a->len = sizeof(a->u.sin6);
++}
++#endif
++
++
++/*
++ * Function logic borrowed & modified from musl libc, res_msend.c
++ */
++
++static int send_queries(struct ns *ns, int n_ns, struct query *queries, int n_queries)
++{
++	int fd;
++	int timeout = default_timeout * 1000, retry_interval, servfail_retry = 0;
++	len_and_sockaddr from = { };
++#if ENABLE_FEATURE_IPV6
++	int one = 1;
++#endif
++	int recvlen = 0;
++	int n_replies = 0;
++	struct pollfd pfd;
++	unsigned long t0, t1, t2;
++	int nn, qn, next_query = 0;
++
++	from.u.sa.sa_family = AF_INET;
++	from.len = sizeof(from.u.sin);
++
++#if ENABLE_FEATURE_IPV6
++	for (nn = 0; nn < n_ns; nn++) {
++		if (ns[nn].addr.u.sa.sa_family == AF_INET6) {
++			from.u.sa.sa_family = AF_INET6;
++			from.len = sizeof(from.u.sin6);
++			break;
++		}
++	}
++#endif
++
++	/* Get local address and open/bind a socket */
++	fd = socket(from.u.sa.sa_family, SOCK_DGRAM|SOCK_CLOEXEC|SOCK_NONBLOCK, 0);
++
++#if ENABLE_FEATURE_IPV6
++	/* Handle case where system lacks IPv6 support */
++	if (fd < 0 && from.u.sa.sa_family == AF_INET6 && errno == EAFNOSUPPORT) {
++		fd = socket(AF_INET, SOCK_DGRAM|SOCK_CLOEXEC|SOCK_NONBLOCK, 0);
++		from.u.sa.sa_family = AF_INET;
++	}
++#endif
++
++	if (fd < 0)
++		return -1;
++
++	if (bind(fd, &from.u.sa, from.len) < 0) {
++		close(fd);
++		return -1;
++	}
++
++#if ENABLE_FEATURE_IPV6
++	/* Convert any IPv4 addresses in a mixed environment to v4-mapped */
++	if (from.u.sa.sa_family == AF_INET6) {
++		setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &one, sizeof(one));
++
++		for (nn = 0; nn < n_ns; nn++)
++			to_v4_mapped(&ns[nn].addr);
++	}
++#endif
++
++	pfd.fd = fd;
++	pfd.events = POLLIN;
++	retry_interval = timeout / default_retry;
++	t0 = t2 = mtime();
++	t1 = t2 - retry_interval;
++
++	for (; t2 - t0 < timeout; t2 = mtime()) {
++		if (t2 - t1 >= retry_interval) {
++			for (qn = 0; qn < n_queries; qn++) {
++				if (queries[qn].rlen)
++					continue;
++
++				for (nn = 0; nn < n_ns; nn++) {
++					sendto(fd, queries[qn].query, queries[qn].qlen,
++					       MSG_NOSIGNAL, &ns[nn].addr.u.sa, ns[nn].addr.len);
++				}
++			}
++
++			t1 = t2;
++			servfail_retry = 2 * n_queries;
++		}
++
++		/* Wait for a response, or until time to retry */
++		if (poll(&pfd, 1, t1+retry_interval-t2) <= 0)
++			continue;
++
++		while (1) {
++			recvlen = recvfrom(fd, queries[next_query].reply,
++			                   sizeof(queries[next_query].reply), 0,
++			                   &from.u.sa, &from.len);
++
++			/* read error */
++			if (recvlen < 0)
++				break;
++
++			/* Ignore non-identifiable packets */
++			if (recvlen < 4)
++				continue;
++
++			/* Ignore replies from addresses we didn't send to */
++			for (nn = 0; nn < n_ns; nn++)
++				if (memcmp(&from.u.sa, &ns[nn].addr.u.sa, from.len) == 0)
++					break;
++
++			if (nn >= n_ns)
++				continue;
++
++			/* Find which query this answer goes with, if any */
++			for (qn = next_query; qn < n_queries; qn++)
++				if (!memcmp(queries[next_query].reply, queries[qn].query, 2))
++					break;
++
++			if (qn >= n_queries || queries[qn].rlen)
++				continue;
++
++			queries[qn].rcode = queries[next_query].reply[3] & 15;
++			queries[qn].latency = mtime() - t0;
++			queries[qn].n_ns = nn;
++
++			ns[nn].replies++;
++
++			/* Only accept positive or negative responses;
++			 * retry immediately on server failure, and ignore
++			 * all other codes such as refusal. */
++			switch (queries[qn].rcode) {
++			case 0:
++			case 3:
++				break;
++
++			case 2:
++				if (servfail_retry && servfail_retry--) {
++					ns[nn].failures++;
++					sendto(fd, queries[qn].query, queries[qn].qlen,
++					       MSG_NOSIGNAL, &ns[nn].addr.u.sa, ns[nn].addr.len);
++				}
++				/* fall through */
++
++			default:
++				continue;
++			}
++
++			/* Store answer */
++			n_replies++;
++
++			queries[qn].rlen = recvlen;
++
++			if (qn == next_query) {
++				while (next_query < n_queries) {
++					if (!queries[next_query].rlen)
++						break;
++
++					next_query++;
++				}
++			}
++			else {
++				memcpy(queries[qn].reply, queries[next_query].reply, recvlen);
++			}
++
++			if (next_query >= n_queries)
++				return n_replies;
++		}
++	}
++
++	return n_replies;
++}
++
++static struct ns *add_ns(struct ns **ns, int *n_ns, const char *addr)
++{
++	char portstr[sizeof("65535")], *p;
++	len_and_sockaddr a = { };
++	struct ns *tmp;
++	struct addrinfo *ai, *aip, hints = {
++		.ai_flags = AI_NUMERICSERV,
++		.ai_socktype = SOCK_DGRAM
++	};
++
++	if (parse_nsaddr(addr, &a)) {
++		/* Maybe we got a domain name, attempt to resolve it using the standard
++		 * resolver routines */
++
++		p = strchr(addr, '#');
++		snprintf(portstr, sizeof(portstr), "%hu",
++		         (unsigned short)(p ? strtoul(p, NULL, 10) : default_port));
++
++		if (!getaddrinfo(addr, portstr, &hints, &ai)) {
++			for (aip = ai; aip; aip = aip->ai_next) {
++				if (aip->ai_addr->sa_family != AF_INET &&
++				    aip->ai_addr->sa_family != AF_INET6)
++					continue;
++
++#if ! ENABLE_FEATURE_IPV6
++				if (aip->ai_addr->sa_family != AF_INET)
++					continue;
++#endif
++
++				tmp = realloc(*ns, sizeof(**ns) * (*n_ns + 1));
++
++				if (!tmp)
++					return NULL;
++
++				*ns = tmp;
++
++				(*ns)[*n_ns].name = addr;
++				(*ns)[*n_ns].replies = 0;
++				(*ns)[*n_ns].failures = 0;
++				(*ns)[*n_ns].addr.len = aip->ai_addrlen;
++
++				memcpy(&(*ns)[*n_ns].addr.u.sa, aip->ai_addr, aip->ai_addrlen);
++
++				(*n_ns)++;
++			}
++
++			freeaddrinfo(ai);
++
++			return &(*ns)[*n_ns];
++		}
++
++		return NULL;
++	}
++
++	tmp = realloc(*ns, sizeof(**ns) * (*n_ns + 1));
++
++	if (!tmp)
++		return NULL;
++
++	*ns = tmp;
++
++	(*ns)[*n_ns].addr = a;
++	(*ns)[*n_ns].name = addr;
++	(*ns)[*n_ns].replies = 0;
++	(*ns)[*n_ns].failures = 0;
++
++	return &(*ns)[(*n_ns)++];
++}
++
++static int parse_resolvconf(struct ns **ns, int *n_ns)
++{
++	int prev_n_ns = *n_ns;
++	char line[128], *p;
++	FILE *resolv;
++
++	if ((resolv = fopen("/etc/resolv.conf", "r")) != NULL) {
++		while (fgets(line, sizeof(line), resolv)) {
++			p = strtok(line, " \t\n");
++
++			if (!p || strcmp(p, "nameserver"))
++				continue;
++
++			p = strtok(NULL, " \t\n");
++
++			if (!p)
++				continue;
++
++			if (!add_ns(ns, n_ns, strdup(p))) {
++				free(p);
++				break;
++			}
++		}
++
++		fclose(resolv);
++	}
++
++	return *n_ns - prev_n_ns;
++}
++
++static struct query *add_query(struct query **queries, int *n_queries,
++                               int type, const char *dname)
++{
++	struct query *tmp;
++	ssize_t qlen;
++
++	tmp = realloc(*queries, sizeof(**queries) * (*n_queries + 1));
++
++	if (!tmp)
++		return NULL;
++
++	memset(&tmp[*n_queries], 0, sizeof(*tmp));
++
++	qlen = res_mkquery(QUERY, dname, C_IN, type, NULL, 0, NULL,
++	                   tmp[*n_queries].query, sizeof(tmp[*n_queries].query));
++
++	tmp[*n_queries].qlen = qlen;
++	tmp[*n_queries].name = dname;
++	*queries = tmp;
++
++	return &tmp[(*n_queries)++];
++}
++
++static char *sal2str(len_and_sockaddr *a)
++{
++	static char buf[INET6_ADDRSTRLEN + 1 + IFNAMSIZ + 1 + 5 + 1];
++	char *p = buf;
++
++#if ENABLE_FEATURE_IPV6
++	if (a->u.sa.sa_family == AF_INET6) {
++		inet_ntop(AF_INET6, &a->u.sin6.sin6_addr, buf, sizeof(buf));
++		p += strlen(p);
++
++		if (a->u.sin6.sin6_scope_id) {
++			if (if_indextoname(a->u.sin6.sin6_scope_id, p + 1)) {
++				*p++ = '%';
++				p += strlen(p);
++			}
++		}
++	}
++	else
++#endif
++	{
++		inet_ntop(AF_INET, &a->u.sin.sin_addr, buf, sizeof(buf));
++		p += strlen(p);
++	}
++
++	sprintf(p, "#%hu", ntohs(a->u.sin.sin_port));
++
++	return buf;
++}
++
++int nslookup_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
++int nslookup_main(int argc, char **argv)
++{
++	int rc = 1;
++	char *ptr, *chr;
++	struct ns *ns = NULL;
++	struct query *queries = NULL;
++	llist_t *type_strings = NULL;
++	int n_ns = 0, n_queries = 0;
++	int c, opts, option_index = 0;
++	int stats = 0, bb_style_counter = 0;
++	unsigned int types = 0;
++	HEADER *header;
++
++#if ENABLE_FEATURE_NSLOOKUP_OPENWRT_LONG_OPTIONS
++	static const char nslookup_longopts[] ALIGN1 =
++		"type\0"		Required_argument	"q"
++		"querytype\0"		Required_argument	"q"
++		"port\0"		Required_argument	"p"
++		"retry\0"		Required_argument	"r"
++		"timeout\0"		Required_argument	"t"
++		"stats\0"		No_argument		"s"
++	;
++
++	opts = getopt32long(argv, "^" "+q:*p:+r:+t:+s" "\0" "q::",
++			nslookup_longopts,
++	                &type_strings, &default_port,
++	                &default_retry, &default_timeout);
++#else
++	opts = getopt32(argv, "^" "+q:*p:+r:+t:+s" "\0" "q::",
++	                &type_strings, &default_port,
++	                &default_retry, &default_timeout);
++#endif
++
++	while (type_strings) {
++		ptr = llist_pop(&type_strings);
++
++		/* skip leading text, e.g. when invoked with -querytype=AAAA */
++		if ((chr = strchr(ptr, '=')) != NULL)
++			ptr = chr + 1;
++
++		for (c = 0; qtypes[c].name; c++)
++			if (!strcmp(qtypes[c].name, ptr))
++				break;
++
++		if (!qtypes[c].name) {
++			fprintf(stderr, "Invalid query type \"%s\"\n", ptr);
++			goto out;
++		}
++
++		types |= (1 << c);
++	}
++
++	if (default_port > 65535) {
++		fprintf(stderr, "Invalid server port\n");
++		goto out;
++	}
++
++	if (!default_retry) {
++		fprintf(stderr, "Invalid retry value\n");
++		goto out;
++	}
++
++	if (!default_timeout) {
++		fprintf(stderr, "Invalid timeout value\n");
++		goto out;
++	}
++
++	stats = (opts & 16);
++
++	if (optind >= argc)
++		bb_show_usage();
++
++	for (option_index = optind;
++	     option_index < ((argc - optind) > 1 ? argc - 1 : argc);
++	     option_index++) {
++
++		/* No explicit type given, guess query type.
++		 * If we can convert the domain argument into a ptr (means that
++		 * inet_pton() could read it) we assume a PTR request, else
++		 * we issue A+AAAA queries and switch to an output format
++		 * mimicking the one of the traditional nslookup applet. */
++		if (types == 0) {
++			ptr = make_ptr(argv[option_index]);
++
++			if (ptr) {
++				add_query(&queries, &n_queries, T_PTR, ptr);
++			}
++			else {
++				bb_style_counter = 1;
++				add_query(&queries, &n_queries, T_A, argv[option_index]);
++#if ENABLE_FEATURE_IPV6
++				add_query(&queries, &n_queries, T_AAAA, argv[option_index]);
++#endif
++			}
++		}
++		else {
++			for (c = 0; qtypes[c].name; c++)
++				if (types & (1 << c))
++					add_query(&queries, &n_queries, qtypes[c].type,
++					          argv[option_index]);
++		}
++	}
++
++	/* Use given DNS server if present */
++	if (option_index < argc) {
++		if (!add_ns(&ns, &n_ns, argv[option_index])) {
++			fprintf(stderr, "Invalid NS server address \"%s\": %s\n",
++			        argv[option_index], strerror(errno));
++			goto out;
++		}
++	}
++	else {
++		parse_resolvconf(&ns, &n_ns);
++	}
++
++	/* Fall back to localhost if we could not find NS in resolv.conf */
++	if (n_ns == 0) {
++		add_ns(&ns, &n_ns, "127.0.0.1");
++	}
++
++	for (c = 0; c < n_ns; c++) {
++		rc = send_queries(&ns[c], 1, queries, n_queries);
++
++		if (rc < 0) {
++			fprintf(stderr, "Failed to send queries: %s\n", strerror(errno));
++			goto out;
++		} else if (rc > 0) {
++			break;
++		}
++	}
++
++	if (c >= n_ns) {
++		fprintf(stderr,
++			    ";; connection timed out; no servers could be reached\n\n");
++
++		return 1;
++	}
++
++	printf("Server:\t\t%s\n", ns[c].name);
++	printf("Address:\t%s\n", sal2str(&ns[c].addr));
++
++	if (stats) {
++		printf("Replies:\t%d\n", ns[c].replies);
++		printf("Failures:\t%d\n", ns[c].failures);
++	}
++
++	printf("\n");
++
++	for (rc = 0; rc < n_queries; rc++) {
++		if (stats) {
++			printf("Query #%d completed in %lums:\n", rc, queries[rc].latency);
++		}
++
++		if (queries[rc].rcode != 0) {
++			printf("** server can't find %s: %s\n", queries[rc].name,
++			       rcodes[queries[rc].rcode]);
++			continue;
++		}
++
++		c = 0;
++
++		if (queries[rc].rlen) {
++			if (!bb_style_counter) {
++				header = (HEADER *)queries[rc].reply;
++
++				if (!header->aa)
++					printf("Non-authoritative answer:\n");
++
++				c = parse_reply(queries[rc].reply, queries[rc].rlen, NULL);
++			}
++			else {
++				c = parse_reply(queries[rc].reply, queries[rc].rlen,
++				                &bb_style_counter);
++			}
++		}
++
++		if (c == 0)
++			printf("*** Can't find %s: No answer\n", queries[rc].name);
++		else if (c < 0)
++			printf("*** Can't find %s: Parse error\n", queries[rc].name);
++
++		if (!bb_style_counter)
++			printf("\n");
++	}
++
++	rc = 0;
++
++out:
++	if (n_ns)
++		free(ns);
++
++	if (n_queries)
++		free(queries);
++
++	return rc;
++}

--- a/package/utils/busybox/Config-defaults.in
+++ b/package/utils/busybox/Config-defaults.in
@@ -2459,13 +2459,19 @@
 	default y
 config BUSYBOX_DEFAULT_NSLOOKUP
 	bool
-	default y
+	default n
 config BUSYBOX_DEFAULT_FEATURE_NSLOOKUP_BIG
 	bool
-	default y
+	default n
 config BUSYBOX_DEFAULT_FEATURE_NSLOOKUP_LONG_OPTIONS
 	bool
 	default n
+config BUSYBOX_DEFAULT_NSLOOKUP_OPENWRT
+	bool
+	default y
+config BUSYBOX_DEFAULT_FEATURE_NSLOOKUP_OPENWRT_LONG_OPTIONS
+	bool
+	default n
 config BUSYBOX_DEFAULT_NTPD
 	bool
 	default y

--- a/package/utils/busybox/Makefile
+++ b/package/utils/busybox/Makefile
@@ -96,7 +96,7 @@
 LDLIBS += $(call BUSYBOX_IF_ENABLED,PAM,pam pam_misc pthread)
 
 ifeq ($(CONFIG_USE_GLIBC),y)
-  LDLIBS += $(call BUSYBOX_IF_ENABLED,NSLOOKUP,resolv)
+  LDLIBS += $(call BUSYBOX_IF_ENABLED,NSLOOKUP_OPENWRT,resolv)
 endif
 
 ifeq ($(BUILD_VARIANT),selinux)

--- /dev/null
+++ b/target/linux/generic/hack-5.4/952-net-conntrack-events-support-multiple-registrant.patch
@@ -0,0 +1,313 @@
+From 42824d4b753f84ccf885eca602c5037338b546c8 Mon Sep 17 00:00:00 2001
+From: Zhi Chen <zhichen@codeaurora.org>
+Date: Tue, 13 Jan 2015 14:28:18 -0800
+Subject: [PATCH 3/3] net: conntrack events, support multiple registrant
+
+Merging this patch from kernel 3.4:
+This was supported by old (.28) kernel versions but removed
+because of it's overhead.
+But we need this feature for NA connection manager. Both ipv4
+and ipv6 modules needs to register themselves to ct events.
+
+Change-Id: Iebfb254590fb594f5baf232f849d1b7ae45ef757
+Signed-off-by: Zhi Chen <zhichen@codeaurora.org>
+---
+ include/net/netfilter/nf_conntrack_ecache.h | 42 ++++++++++++++++++-
+ include/net/netns/conntrack.h               |  4 ++
+ net/netfilter/Kconfig                       |  8 ++++
+ net/netfilter/nf_conntrack_core.c           |  4 ++
+ net/netfilter/nf_conntrack_ecache.c         | 63 +++++++++++++++++++++++++++++
+ net/netfilter/nf_conntrack_netlink.c        | 17 ++++++++
+ 6 files changed, 137 insertions(+), 1 deletion(-)
+
+--- a/include/net/netfilter/nf_conntrack_ecache.h
++++ b/include/net/netfilter/nf_conntrack_ecache.h
+@@ -72,6 +72,10 @@ struct nf_ct_event {
+ 	int report;
+ };
+ 
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++extern int nf_conntrack_register_notifier(struct net *net, struct notifier_block *nb);
++extern int nf_conntrack_unregister_notifier(struct net *net, struct notifier_block *nb);
++#else
+ struct nf_ct_event_notifier {
+ 	int (*fcn)(unsigned int events, struct nf_ct_event *item);
+ };
+@@ -80,6 +84,7 @@ int nf_conntrack_register_notifier(struc
+ 				   struct nf_ct_event_notifier *nb);
+ void nf_conntrack_unregister_notifier(struct net *net,
+ 				      struct nf_ct_event_notifier *nb);
++#endif
+ 
+ void nf_ct_deliver_cached_events(struct nf_conn *ct);
+ int nf_conntrack_eventmask_report(unsigned int eventmask, struct nf_conn *ct,
+@@ -105,11 +110,13 @@ static inline void
+ nf_conntrack_event_cache(enum ip_conntrack_events event, struct nf_conn *ct)
+ {
+ #ifdef CONFIG_NF_CONNTRACK_EVENTS
+-	struct net *net = nf_ct_net(ct);
+ 	struct nf_conntrack_ecache *e;
++#ifndef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++	struct net *net = nf_ct_net(ct);
+ 
+ 	if (!rcu_access_pointer(net->ct.nf_conntrack_event_cb))
+ 		return;
++#endif
+ 
+ 	e = nf_ct_ecache_find(ct);
+ 	if (e == NULL)
+@@ -124,10 +131,12 @@ nf_conntrack_event_report(enum ip_conntr
+ 			  u32 portid, int report)
+ {
+ #ifdef CONFIG_NF_CONNTRACK_EVENTS
++#ifndef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
+ 	const struct net *net = nf_ct_net(ct);
+ 
+ 	if (!rcu_access_pointer(net->ct.nf_conntrack_event_cb))
+ 		return 0;
++#endif
+ 
+ 	return nf_conntrack_eventmask_report(1 << event, ct, portid, report);
+ #else
+@@ -139,10 +148,12 @@ static inline int
+ nf_conntrack_event(enum ip_conntrack_events event, struct nf_conn *ct)
+ {
+ #ifdef CONFIG_NF_CONNTRACK_EVENTS
++#ifndef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
+ 	const struct net *net = nf_ct_net(ct);
+ 
+ 	if (!rcu_access_pointer(net->ct.nf_conntrack_event_cb))
+ 		return 0;
++#endif
+ 
+ 	return nf_conntrack_eventmask_report(1 << event, ct, 0, 0);
+ #else
+--- a/include/net/netns/conntrack.h
++++ b/include/net/netns/conntrack.h
+@@ -112,7 +112,11 @@ struct netns_ct {
+ 
+ 	struct ct_pcpu __percpu *pcpu_lists;
+ 	struct ip_conntrack_stat __percpu *stat;
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++	struct atomic_notifier_head nf_conntrack_chain;
++#else
+ 	struct nf_ct_event_notifier __rcu *nf_conntrack_event_cb;
++#endif
+ 	struct nf_exp_event_notifier __rcu *nf_expect_event_cb;
+ 	struct nf_ip_net	nf_ct_proto;
+ #if defined(CONFIG_NF_CONNTRACK_LABELS)
+--- a/net/netfilter/Kconfig
++++ b/net/netfilter/Kconfig
+@@ -148,6 +148,14 @@ config NF_CONNTRACK_RTCACHE
+ 	  To compile it as a module, choose M here.  If unsure, say N.
+ 	  The module will be called nf_conntrack_rtcache.
+ 
++config NF_CONNTRACK_CHAIN_EVENTS
++	bool "Register multiple callbacks to ct events"
++	depends on NF_CONNTRACK_EVENTS
++	help
++	  Support multiple registrations.
++
++	  If unsure, say `N'.
++
+ config NF_CONNTRACK_TIMEOUT
+ 	bool  'Connection tracking timeout'
+ 	depends on NETFILTER_ADVANCED
+--- a/net/netfilter/nf_conntrack_core.c
++++ b/net/netfilter/nf_conntrack_core.c
+@@ -2592,6 +2592,9 @@ int nf_conntrack_init_net(struct net *ne
+ 	nf_conntrack_helper_pernet_init(net);
+ 	nf_conntrack_proto_pernet_init(net);
+ 
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++	ATOMIC_INIT_NOTIFIER_HEAD(&net->ct.nf_conntrack_chain);
++#endif
+ 	return 0;
+ 
+ err_expect:
+--- a/net/netfilter/nf_conntrack_ecache.c
++++ b/net/netfilter/nf_conntrack_ecache.c
+@@ -17,6 +17,9 @@
+ #include <linux/stddef.h>
+ #include <linux/err.h>
+ #include <linux/percpu.h>
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++#include <linux/notifier.h>
++#endif
+ #include <linux/kernel.h>
+ #include <linux/netdevice.h>
+ #include <linux/slab.h>
+@@ -116,7 +119,35 @@ static void ecache_work(struct work_stru
+ 	if (delay >= 0)
+ 		schedule_delayed_work(&ctnet->ecache_dwork, delay);
+ }
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++int nf_conntrack_eventmask_report(unsigned int eventmask, struct nf_conn *ct,
++				  u32 portid, int report)
++{
++	struct nf_conntrack_ecache *e;
++	struct net *net = nf_ct_net(ct);
++
++	e = nf_ct_ecache_find(ct);
++	if (e == NULL)
++		return 0;
++
++	if (nf_ct_is_confirmed(ct)) {
++		struct nf_ct_event item = {
++			.ct = ct,
++			.portid	= e->portid ? e->portid : portid,
++			.report = report
++		};
++		/* This is a resent of a destroy event? If so, skip missed */
++		unsigned long missed = e->portid ? 0 : e->missed;
++
++		if (!((eventmask | missed) & e->ctmask))
++			return 0;
+ 
++		atomic_notifier_call_chain(&net->ct.nf_conntrack_chain, eventmask | missed, &item);
++	}
++
++	return 0;
++}
++#else
+ int nf_conntrack_eventmask_report(unsigned int eventmask, struct nf_conn *ct,
+ 				  u32 portid, int report)
+ {
+@@ -171,10 +202,52 @@ out_unlock:
+ 	rcu_read_unlock();
+ 	return ret;
+ }
++#endif
+ EXPORT_SYMBOL_GPL(nf_conntrack_eventmask_report);
+ 
+ /* deliver cached events and clear cache entry - must be called with locally
+  * disabled softirqs */
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++void nf_ct_deliver_cached_events(struct nf_conn *ct)
++{
++	unsigned long events, missed;
++	struct nf_conntrack_ecache *e;
++	struct nf_ct_event item;
++	struct net *net = nf_ct_net(ct);
++
++	e = nf_ct_ecache_find(ct);
++	if (e == NULL)
++		return;
++
++	events = xchg(&e->cache, 0);
++
++	if (!nf_ct_is_confirmed(ct) || nf_ct_is_dying(ct) || !events)
++		return;
++
++	/* We make a copy of the missed event cache without taking
++	 * the lock, thus we may send missed events twice. However,
++	 * this does not harm and it happens very rarely. */
++	missed = e->missed;
++
++	if (!((events | missed) & e->ctmask))
++		return;
++
++	item.ct = ct;
++	item.portid = 0;
++	item.report = 0;
++
++	atomic_notifier_call_chain(&net->ct.nf_conntrack_chain,
++			events | missed,
++			&item);
++
++	if (likely(!missed))
++		return;
++
++	spin_lock_bh(&ct->lock);
++		e->missed &= ~missed;
++	spin_unlock_bh(&ct->lock);
++}
++#else
+ void nf_ct_deliver_cached_events(struct nf_conn *ct)
+ {
+ 	struct net *net = nf_ct_net(ct);
+@@ -225,6 +298,7 @@ void nf_ct_deliver_cached_events(struct
+ out_unlock:
+ 	rcu_read_unlock();
+ }
++#endif
+ EXPORT_SYMBOL_GPL(nf_ct_deliver_cached_events);
+ 
+ void nf_ct_expect_event_report(enum ip_conntrack_expect_events event,
+@@ -257,6 +331,13 @@ out_unlock:
+ 	rcu_read_unlock();
+ }
+ 
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++int nf_conntrack_register_notifier(struct net *net,
++				   struct notifier_block *nb)
++{
++        return atomic_notifier_chain_register(&net->ct.nf_conntrack_chain, nb);
++}
++#else
+ int nf_conntrack_register_notifier(struct net *net,
+ 				   struct nf_ct_event_notifier *new)
+ {
+@@ -277,8 +358,15 @@ out_unlock:
+ 	mutex_unlock(&nf_ct_ecache_mutex);
+ 	return ret;
+ }
++#endif
+ EXPORT_SYMBOL_GPL(nf_conntrack_register_notifier);
+ 
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++int nf_conntrack_unregister_notifier(struct net *net, struct notifier_block *nb)
++{
++	return atomic_notifier_chain_unregister(&net->ct.nf_conntrack_chain, nb);
++}
++#else
+ void nf_conntrack_unregister_notifier(struct net *net,
+ 				      struct nf_ct_event_notifier *new)
+ {
+@@ -292,6 +380,7 @@ void nf_conntrack_unregister_notifier(st
+ 	mutex_unlock(&nf_ct_ecache_mutex);
+ 	/* synchronize_rcu() is called from ctnetlink_exit. */
+ }
++#endif
+ EXPORT_SYMBOL_GPL(nf_conntrack_unregister_notifier);
+ 
+ int nf_ct_expect_register_notifier(struct net *net,
+--- a/net/netfilter/nf_conntrack_netlink.c
++++ b/net/netfilter/nf_conntrack_netlink.c
+@@ -677,13 +677,20 @@ static size_t ctnetlink_nlmsg_size(const
+ }
+ 
+ static int
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++ctnetlink_conntrack_event(struct notifier_block *this, unsigned long events, void *ptr)
++#else
+ ctnetlink_conntrack_event(unsigned int events, struct nf_ct_event *item)
++#endif
+ {
+ 	const struct nf_conntrack_zone *zone;
+ 	struct net *net;
+ 	struct nlmsghdr *nlh;
+ 	struct nfgenmsg *nfmsg;
+ 	struct nlattr *nest_parms;
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++	struct nf_ct_event *item = (struct nf_ct_event *)ptr;
++#endif
+ 	struct nf_conn *ct = item->ct;
+ 	struct sk_buff *skb;
+ 	unsigned int type;
+@@ -3504,9 +3511,15 @@ static int ctnetlink_stat_exp_cpu(struct
+ }
+ 
+ #ifdef CONFIG_NF_CONNTRACK_EVENTS
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++static struct notifier_block ctnl_notifier = {
++	.notifier_call = ctnetlink_conntrack_event,
++};
++#else
+ static struct nf_ct_event_notifier ctnl_notifier = {
+ 	.fcn = ctnetlink_conntrack_event,
+ };
++#endif
+ 
+ static struct nf_exp_event_notifier ctnl_notifier_exp = {
+ 	.fcn = ctnetlink_expect_event,

--- /dev/null
+++ b/target/linux/generic/hack-5.4/992-add-ndo-do-ioctl.patch
@@ -0,0 +1,12 @@
+--- a/net/wireless/wext-core.c
++++ b/net/wireless/wext-core.c
+@@ -956,6 +956,9 @@ static int wireless_process_ioctl(struct
+ 		else if (private)
+ 			return private(dev, iwr, cmd, info, handler);
+ 	}
++	/* Old driver API : call driver ioctl handler */
++	if (dev->netdev_ops->ndo_do_ioctl)
++		return dev->netdev_ops->ndo_do_ioctl(dev, (struct ifreq *) iwr, cmd);
+ 	return -EOPNOTSUPP;
+ }
+ 

--- /dev/null
+++ b/target/linux/generic/hack-5.10/952-net-conntrack-events-support-multiple-registrant.patch
@@ -0,0 +1,313 @@
+From 42824d4b753f84ccf885eca602c5037338b546c8 Mon Sep 17 00:00:00 2001
+From: Zhi Chen <zhichen@codeaurora.org>
+Date: Tue, 13 Jan 2015 14:28:18 -0800
+Subject: [PATCH 3/3] net: conntrack events, support multiple registrant
+
+Merging this patch from kernel 3.4:
+This was supported by old (.28) kernel versions but removed
+because of it's overhead.
+But we need this feature for NA connection manager. Both ipv4
+and ipv6 modules needs to register themselves to ct events.
+
+Change-Id: Iebfb254590fb594f5baf232f849d1b7ae45ef757
+Signed-off-by: Zhi Chen <zhichen@codeaurora.org>
+---
+ include/net/netfilter/nf_conntrack_ecache.h | 42 ++++++++++++++++++-
+ include/net/netns/conntrack.h               |  4 ++
+ net/netfilter/Kconfig                       |  8 ++++
+ net/netfilter/nf_conntrack_core.c           |  4 ++
+ net/netfilter/nf_conntrack_ecache.c         | 63 +++++++++++++++++++++++++++++
+ net/netfilter/nf_conntrack_netlink.c        | 17 ++++++++
+ 6 files changed, 137 insertions(+), 1 deletion(-)
+
+--- a/include/net/netfilter/nf_conntrack_ecache.h
++++ b/include/net/netfilter/nf_conntrack_ecache.h
+@@ -72,6 +72,10 @@ struct nf_ct_event {
+ 	int report;
+ };
+ 
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++extern int nf_conntrack_register_notifier(struct net *net, struct notifier_block *nb);
++extern int nf_conntrack_unregister_notifier(struct net *net, struct notifier_block *nb);
++#else
+ struct nf_ct_event_notifier {
+ 	int (*fcn)(unsigned int events, struct nf_ct_event *item);
+ };
+@@ -80,6 +84,7 @@ int nf_conntrack_register_notifier(struc
+ 				   struct nf_ct_event_notifier *nb);
+ void nf_conntrack_unregister_notifier(struct net *net,
+ 				      struct nf_ct_event_notifier *nb);
++#endif
+ 
+ void nf_ct_deliver_cached_events(struct nf_conn *ct);
+ int nf_conntrack_eventmask_report(unsigned int eventmask, struct nf_conn *ct,
+@@ -105,11 +110,13 @@ static inline void
+ nf_conntrack_event_cache(enum ip_conntrack_events event, struct nf_conn *ct)
+ {
+ #ifdef CONFIG_NF_CONNTRACK_EVENTS
+-	struct net *net = nf_ct_net(ct);
+ 	struct nf_conntrack_ecache *e;
++#ifndef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++	struct net *net = nf_ct_net(ct);
+ 
+ 	if (!rcu_access_pointer(net->ct.nf_conntrack_event_cb))
+ 		return;
++#endif
+ 
+ 	e = nf_ct_ecache_find(ct);
+ 	if (e == NULL)
+@@ -124,10 +131,12 @@ nf_conntrack_event_report(enum ip_conntr
+ 			  u32 portid, int report)
+ {
+ #ifdef CONFIG_NF_CONNTRACK_EVENTS
++#ifndef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
+ 	const struct net *net = nf_ct_net(ct);
+ 
+ 	if (!rcu_access_pointer(net->ct.nf_conntrack_event_cb))
+ 		return 0;
++#endif
+ 
+ 	return nf_conntrack_eventmask_report(1 << event, ct, portid, report);
+ #else
+@@ -139,10 +148,12 @@ static inline int
+ nf_conntrack_event(enum ip_conntrack_events event, struct nf_conn *ct)
+ {
+ #ifdef CONFIG_NF_CONNTRACK_EVENTS
++#ifndef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
+ 	const struct net *net = nf_ct_net(ct);
+ 
+ 	if (!rcu_access_pointer(net->ct.nf_conntrack_event_cb))
+ 		return 0;
++#endif
+ 
+ 	return nf_conntrack_eventmask_report(1 << event, ct, 0, 0);
+ #else
+--- a/include/net/netns/conntrack.h
++++ b/include/net/netns/conntrack.h
+@@ -112,7 +112,11 @@ struct netns_ct {
+ 
+ 	struct ct_pcpu __percpu *pcpu_lists;
+ 	struct ip_conntrack_stat __percpu *stat;
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++	struct atomic_notifier_head nf_conntrack_chain;
++#else
+ 	struct nf_ct_event_notifier __rcu *nf_conntrack_event_cb;
++#endif
+ 	struct nf_exp_event_notifier __rcu *nf_expect_event_cb;
+ 	struct nf_ip_net	nf_ct_proto;
+ #if defined(CONFIG_NF_CONNTRACK_LABELS)
+--- a/net/netfilter/Kconfig
++++ b/net/netfilter/Kconfig
+@@ -136,6 +136,14 @@ config NF_CONNTRACK_EVENTS
+ 
+ 	  If unsure, say `N'.
+ 
++config NF_CONNTRACK_CHAIN_EVENTS
++	bool "Register multiple callbacks to ct events"
++	depends on NF_CONNTRACK_EVENTS
++	help
++	  Support multiple registrations.
++
++	  If unsure, say `N'.
++
+ config NF_CONNTRACK_TIMEOUT
+ 	bool  'Connection tracking timeout'
+ 	depends on NETFILTER_ADVANCED
+--- a/net/netfilter/nf_conntrack_core.c
++++ b/net/netfilter/nf_conntrack_core.c
+@@ -2744,6 +2744,9 @@ int nf_conntrack_init_net(struct net *ne
+ 	nf_conntrack_helper_pernet_init(net);
+ 	nf_conntrack_proto_pernet_init(net);
+ 
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++	ATOMIC_INIT_NOTIFIER_HEAD(&net->ct.nf_conntrack_chain);
++#endif
+ 	return 0;
+ 
+ err_expect:
+--- a/net/netfilter/nf_conntrack_ecache.c
++++ b/net/netfilter/nf_conntrack_ecache.c
+@@ -17,6 +17,9 @@
+ #include <linux/stddef.h>
+ #include <linux/err.h>
+ #include <linux/percpu.h>
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++#include <linux/notifier.h>
++#endif
+ #include <linux/kernel.h>
+ #include <linux/netdevice.h>
+ #include <linux/slab.h>
+@@ -129,7 +132,35 @@ static void ecache_work(struct work_stru
+ 	if (delay >= 0)
+ 		schedule_delayed_work(&ctnet->ecache_dwork, delay);
+ }
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++int nf_conntrack_eventmask_report(unsigned int eventmask, struct nf_conn *ct,
++				  u32 portid, int report)
++{
++	struct nf_conntrack_ecache *e;
++	struct net *net = nf_ct_net(ct);
++
++	e = nf_ct_ecache_find(ct);
++	if (e == NULL)
++		return 0;
++
++	if (nf_ct_is_confirmed(ct)) {
++		struct nf_ct_event item = {
++			.ct = ct,
++			.portid	= e->portid ? e->portid : portid,
++			.report = report
++		};
++		/* This is a resent of a destroy event? If so, skip missed */
++		unsigned long missed = e->portid ? 0 : e->missed;
++
++		if (!((eventmask | missed) & e->ctmask))
++			return 0;
+ 
++		atomic_notifier_call_chain(&net->ct.nf_conntrack_chain, eventmask | missed, &item);
++	}
++
++	return 0;
++}
++#else
+ int nf_conntrack_eventmask_report(unsigned int eventmask, struct nf_conn *ct,
+ 				  u32 portid, int report)
+ {
+@@ -184,10 +215,52 @@ out_unlock:
+ 	rcu_read_unlock();
+ 	return ret;
+ }
++#endif
+ EXPORT_SYMBOL_GPL(nf_conntrack_eventmask_report);
+ 
+ /* deliver cached events and clear cache entry - must be called with locally
+  * disabled softirqs */
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++void nf_ct_deliver_cached_events(struct nf_conn *ct)
++{
++	unsigned long events, missed;
++	struct nf_conntrack_ecache *e;
++	struct nf_ct_event item;
++	struct net *net = nf_ct_net(ct);
++
++	e = nf_ct_ecache_find(ct);
++	if (e == NULL)
++		return;
++
++	events = xchg(&e->cache, 0);
++
++	if (!nf_ct_is_confirmed(ct) || nf_ct_is_dying(ct) || !events)
++		return;
++
++	/* We make a copy of the missed event cache without taking
++	 * the lock, thus we may send missed events twice. However,
++	 * this does not harm and it happens very rarely. */
++	missed = e->missed;
++
++	if (!((events | missed) & e->ctmask))
++		return;
++
++	item.ct = ct;
++	item.portid = 0;
++	item.report = 0;
++
++	atomic_notifier_call_chain(&net->ct.nf_conntrack_chain,
++			events | missed,
++			&item);
++
++	if (likely(!missed))
++		return;
++
++	spin_lock_bh(&ct->lock);
++		e->missed &= ~missed;
++	spin_unlock_bh(&ct->lock);
++}
++#else
+ void nf_ct_deliver_cached_events(struct nf_conn *ct)
+ {
+ 	struct net *net = nf_ct_net(ct);
+@@ -238,6 +311,7 @@ void nf_ct_deliver_cached_events(struct
+ out_unlock:
+ 	rcu_read_unlock();
+ }
++#endif
+ EXPORT_SYMBOL_GPL(nf_ct_deliver_cached_events);
+ 
+ void nf_ct_expect_event_report(enum ip_conntrack_expect_events event,
+@@ -270,6 +344,13 @@ out_unlock:
+ 	rcu_read_unlock();
+ }
+ 
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++int nf_conntrack_register_notifier(struct net *net,
++				   struct notifier_block *nb)
++{
++        return atomic_notifier_chain_register(&net->ct.nf_conntrack_chain, nb);
++}
++#else
+ int nf_conntrack_register_notifier(struct net *net,
+ 				   struct nf_ct_event_notifier *new)
+ {
+@@ -290,8 +371,15 @@ out_unlock:
+ 	mutex_unlock(&nf_ct_ecache_mutex);
+ 	return ret;
+ }
++#endif
+ EXPORT_SYMBOL_GPL(nf_conntrack_register_notifier);
+ 
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++int nf_conntrack_unregister_notifier(struct net *net, struct notifier_block *nb)
++{
++	return atomic_notifier_chain_unregister(&net->ct.nf_conntrack_chain, nb);
++}
++#else
+ void nf_conntrack_unregister_notifier(struct net *net,
+ 				      struct nf_ct_event_notifier *new)
+ {
+@@ -305,6 +393,7 @@ void nf_conntrack_unregister_notifier(st
+ 	mutex_unlock(&nf_ct_ecache_mutex);
+ 	/* synchronize_rcu() is called from ctnetlink_exit. */
+ }
++#endif
+ EXPORT_SYMBOL_GPL(nf_conntrack_unregister_notifier);
+ 
+ int nf_ct_expect_register_notifier(struct net *net,
+--- a/net/netfilter/nf_conntrack_netlink.c
++++ b/net/netfilter/nf_conntrack_netlink.c
+@@ -703,13 +703,20 @@ static size_t ctnetlink_nlmsg_size(const
+ }
+ 
+ static int
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++ctnetlink_conntrack_event(struct notifier_block *this, unsigned long events, void *ptr)
++#else
+ ctnetlink_conntrack_event(unsigned int events, struct nf_ct_event *item)
++#endif
+ {
+ 	const struct nf_conntrack_zone *zone;
+ 	struct net *net;
+ 	struct nlmsghdr *nlh;
+ 	struct nfgenmsg *nfmsg;
+ 	struct nlattr *nest_parms;
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++	struct nf_ct_event *item = (struct nf_ct_event *)ptr;
++#endif
+ 	struct nf_conn *ct = item->ct;
+ 	struct sk_buff *skb;
+ 	unsigned int type;
+@@ -3784,9 +3791,15 @@ static int ctnetlink_stat_exp_cpu(struct
+ }
+ 
+ #ifdef CONFIG_NF_CONNTRACK_EVENTS
++#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
++static struct notifier_block ctnl_notifier = {
++	.notifier_call = ctnetlink_conntrack_event,
++};
++#else
+ static struct nf_ct_event_notifier ctnl_notifier = {
+ 	.fcn = ctnetlink_conntrack_event,
+ };
++#endif
+ 
+ static struct nf_exp_event_notifier ctnl_notifier_exp = {
+ 	.fcn = ctnetlink_expect_event,

--- /dev/null
+++ b/target/linux/generic/hack-5.10/992-add-ndo-do-ioctl.patch
@@ -0,0 +1,12 @@
+--- a/net/wireless/wext-core.c
++++ b/net/wireless/wext-core.c
+@@ -956,6 +956,9 @@ static int wireless_process_ioctl(struct
+ 		else if (private)
+ 			return private(dev, iwr, cmd, info, handler);
+ 	}
++	/* Old driver API : call driver ioctl handler */
++	if (dev->netdev_ops->ndo_do_ioctl)
++		return dev->netdev_ops->ndo_do_ioctl(dev, (struct ifreq *) iwr, cmd);
+ 	return -EOPNOTSUPP;
+ }
+ 

--- /dev/null
+++ b/tools/ucl/Makefile
@@ -0,0 +1,51 @@
+#
+# Copyright (C) 2019 OpenWrt.org
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+include $(TOPDIR)/rules.mk
+
+PKG_NAME:=ucl
+PKG_VERSION:=1.03
+
+PKG_SOURCE:=$(PKG_NAME)-$(PKG_VERSION).tar.gz
+PKG_SOURCE_URL:=http://www.oberhumer.com/opensource/ucl/download/$(PKG_SOURCE)
+PKG_HASH:=b865299ffd45d73412293369c9754b07637680e5c826915f097577cd27350348
+
+HOST_BUILD_DIR:=$(BUILD_DIR_HOST)/$(PKG_NAME)-$(PKG_VERSION)
+
+include $(INCLUDE_DIR)/host-build.mk
+
+HOSTCC :=gcc
+HOST_CFLAGS +=-std=gnu89
+
+define Host/Prepare
+	$(Host/Prepare/Default)
+	mkdir -p $(STAGING_DIR_HOST)/include/ucl
+endef
+
+define Host/Configure
+	(cd $(HOST_BUILD_DIR); \
+	CC="$(HOSTCC)" \
+	CFLAGS="$(HOST_CFLAGS)" \
+	./configure --prefix=$(STAGING_DIR_HOST) \
+	);
+	$(call Host/Configure/Default)
+endef
+
+define Host/Compile
+	$(MAKE) -C $(HOST_BUILD_DIR)
+endef
+
+define Host/Install
+	$(MAKE) -C $(HOST_BUILD_DIR) install
+endef
+
+define Host/Clean
+	$(MAKE) -C $(HOST_BUILD_DIR) uninstall
+	rm -rf $(HOST_BUILD_DIR)
+	rm -rf $(STAGING_DIR_HOST)/include/ucl
+endef
+
+$(eval $(call HostBuild))

--- /dev/null
+++ b/tools/upx/Makefile
@@ -0,0 +1,35 @@
+#
+# Copyright (C) 2011-2020 OpenWrt.org
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+include $(TOPDIR)/rules.mk
+
+PKG_NAME:=upx
+PKG_VERSION:=3.95
+
+PKG_SOURCE:=$(PKG_NAME)-$(PKG_VERSION)-src.tar.xz
+PKG_SOURCE_URL:=https://github.com/upx/upx/releases/download/v$(PKG_VERSION)
+PKG_HASH:=3b0f55468d285c760fcf5ea865a070b27696393002712054c69ff40d8f7f5592
+
+HOST_BUILD_DIR:=$(BUILD_DIR_HOST)/$(PKG_NAME)-$(PKG_VERSION)-src
+
+include $(INCLUDE_DIR)/host-build.mk
+
+define Host/Compile
+	UPX_UCLDIR=$(STAGING_DIR_HOST) \
+	$(MAKE) -C $(HOST_BUILD_DIR)/src \
+		CXXFLAGS_WERROR="" LDFLAGS="$(HOST_LDFLAGS)" \
+		CXX="$(HOSTCXX)"
+endef
+
+define Host/Install
+	$(CP) $(HOST_BUILD_DIR)/src/upx.out $(STAGING_DIR_HOST)/bin/upx
+endef
+
+define Host/Clean
+	rm -f $(STAGING_DIR_HOST)/bin/upx
+endef
+
+$(eval $(call HostBuild))

--- a/tools/Makefile
+++ b/tools/Makefile
@@ -26,6 +26,7 @@
 tools-y += libressl libtool lzma m4 make-ext4fs missing-macros mkimage
 tools-y += mklibs mm-macros mtd-utils mtools ninja padjffs2 patch-image
 tools-y += patchelf pkgconf quilt squashfskit4 sstrip xxd zip zlib zstd
+tools-y += ucl upx
 tools-$(BUILD_B43_TOOLS) += b43-tools
 tools-$(BUILD_ISL) += isl
 tools-$(BUILD_TOOLCHAIN) += expat gmp mpc mpfr
@@ -37,6 +38,7 @@
 tools-$(CONFIG_USE_SPARSE) += sparse
 
 # builddir dependencies
+$(curdir)/upx/compile := $(curdir)/ucl/compile
 $(curdir)/autoconf/compile := $(curdir)/m4/compile
 $(curdir)/automake/compile := $(curdir)/m4/compile $(curdir)/autoconf/compile $(curdir)/pkgconf/compile $(curdir)/xz/compile
 $(curdir)/b43-tools/compile := $(curdir)/bison/compile
