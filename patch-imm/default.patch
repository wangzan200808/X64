--- a/config/Config-build.in
+++ b/config/Config-build.in
@@ -89,6 +89,7 @@
 
 	config BUILD_PATENTED
 		bool "Compile with support for patented functionality"
+		default y
 		help
 		  When this option is disabled, software which provides patented functionality
 		  will not be built.  In case software provides optional support for patented

--- a/config/Config-images.in
+++ b/config/Config-images.in
@@ -89,7 +89,7 @@
 
 	menuconfig TARGET_ROOTFS_EXT4FS
 		bool "ext4"
-		default y if USES_EXT4
+		default n
 		help
 		  Build an ext4 root filesystem.
 
@@ -240,7 +240,7 @@
 	config GRUB_TIMEOUT
 		string "Seconds to wait before booting the default entry"
 		depends on GRUB_IMAGES || GRUB_EFI_IMAGES
-		default "3"
+		default "0"
 		help
 		  If you don't know, 5 seconds is a reasonable default.
 
--- a/package/base-files/files/bin/config_generate
+++ b/package/base-files/files/bin/config_generate
@@ -162,8 +162,8 @@
		static)
			local ipad
			case "$1" in
-				lan) ipad=${ipaddr:-"192.168.1.1"} ;;
-				*) ipad=${ipaddr:-"192.168.$((addr_offset++)).1"} ;;
+				lan) ipad=${ipaddr:-"10.0.0.1"} ;;
+				*) ipad=${ipaddr:-"10.0.$((addr_offset++)).1"} ;;
			esac

			netm=${netmask:-"255.255.255.0"}
@@ -177,18 +177,7 @@
 		;;
 
 		dhcp)
-			# fixup IPv6 slave interface if parent is a bridge
-			[ "$type" = "bridge" ] && device="br-$1"
-
 			uci set network.$1.proto='dhcp'
-			[ -e /proc/sys/net/ipv6 ] && {
-				uci -q batch <<-EOF
-					delete network.${1}6
-					set network.${1}6='interface'
-					set network.${1}6.device='$device'
-					set network.${1}6.proto='dhcpv6'
-				EOF
-			}
 		;;
 
 		pppoe)
@@ -196,16 +185,8 @@
 				set network.$1.proto='pppoe'
 				set network.$1.username='username'
 				set network.$1.password='password'
+				set network.$1.ipv6='auto'
 			EOF
-			[ -e /proc/sys/net/ipv6 ] && {
-				uci -q batch <<-EOF
-					set network.$1.ipv6='1'
-					delete network.${1}6
-					set network.${1}6='interface'
-					set network.${1}6.device='@${1}'
-					set network.${1}6.proto='dhcpv6'
-				EOF
-			}
 		;;
 
 		ncm|\
@@ -312,7 +293,8 @@
 		delete system.@system[0]
 		add system system
 		set system.@system[-1].hostname='ImmortalWrt'
-		set system.@system[-1].timezone='UTC'
+		set system.@system[-1].zonename='Asia/Hong Kong'
+		set system.@system[-1].timezone='HKT-8'
 		set system.@system[-1].ttylogin='0'
 		set system.@system[-1].log_size='128'
 		set system.@system[-1].urandom_seed='0'

--- a/package/base-files/files/etc/board.d/99-default_network
+++ b/package/base-files/files/etc/board.d/99-default_network
@@ -8,8 +8,15 @@
 
 json_is_a network object && exit 0
 
-ucidef_set_interface_lan 'eth0'
-[ -d /sys/class/net/eth1 ] && ucidef_set_interface_wan 'eth1'
+A=$(ls /sys/class/net | grep -c eth)
+if [ $A -gt 1 ];then
+	let A=A-1
+	ucidef_set_interface_wan eth0
+	for i in $(seq 1 $A);do B="$B eth$i";done
+	ucidef_set_interface_lan "${B#* }"
+else
+	ucidef_set_interface_lan eth0
+fi
 
 board_config_flush

--- a/package/network/services/dnsmasq/files/dhcp.conf
+++ b/package/network/services/dnsmasq/files/dhcp.conf
@@ -1,40 +1,25 @@
-config dnsmasq
-	option domainneeded	1
-	option boguspriv	1
-	option filterwin2k	0  # enable for dial on demand
-	option localise_queries	1
-	option rebind_protection 1  # disable if upstream must serve RFC1918 addresses
-	option rebind_localhost 1  # enable for RBL checking and similar services
-	#list rebind_domain example.lan  # whitelist RFC1918 responses for domains
-	option local	'/lan/'
-	option domain	'lan'
-	option expandhosts	1
-	option min_cache_ttl	3600
-	option use_stale_cache	3600
-	option cachesize	8000
-	option nonegcache	1
-	option authoritative	1
-	option readethers	1
-	option leasefile	'/tmp/dhcp.leases'
-	option resolvfile	'/tmp/resolv.conf.d/resolv.conf.auto'
-	#list server		'/mycompany.local/1.2.3.4'
-	option nonwildcard	1 # bind to & keep track of interfaces
-	#list interface		br-lan
-	#list notinterface	lo
-	#list bogusnxdomain     '64.94.110.11'
-	option localservice	1  # disable to allow DNS requests from non-local subnets
-	option dns_redirect	1
-	option ednspacket_max	1232
-	option filter_aaaa	0
-	option filter_a		0
-	#list addnmount		/some/path # read-only mount path to expose it to dnsmasq
-
-config dhcp lan
-	option interface	lan
-	option start 	100
-	option limit	150
-	option leasetime	12h
-
-config dhcp wan
-	option interface	wan
-	option ignore	1
+config dnsmasq
+	option domainneeded '1'
+	option authoritative '1'
+	option local '/lan/'
+	option domain 'lan'
+	option rebind_protection '1'
+	option rebind_localhost '1'
+	option localservice '0'
+	option nonwildcard '0'
+	option readethers '1'
+	option leasefile '/tmp/dhcp.leases'
+	option sequential_ip '1'
+	option localise_queries '1'
+	option expandhosts '1'
+	option ednspacket_max '1232'
+	option cachesize '1000'
+	option filter_aaaa '0'
+	option filter_a '0'
+ 
+config dhcp 'lan'
+	option interface 'lan'
+	option start '20'
+	option limit '150'
+	option leasetime '24h'
+	option force '1'

--- a/package/network/services/dnsmasq/files/dnsmasq.init
--- a/package/network/services/dnsmasq/files/dnsmasq.init
@@ -415,6 +415,21 @@
 	local mode="$3"
 	local routerstub routername ifdashname
 	local lanaddr lanaddr6 lanaddrs6 ulaprefix
+	
+	network_get_ipaddr lanaddr "lan"
+	if [ -n $lanaddr ]; then
+ 	lanaddr="$(echo "$lanaddr" | sed -e "s/\/24//")"
+	echo "
+	$lanaddr op" >/tmp/hosts/shortcuts
+	if [ -f /etc/nginx/conf.d/shortcuts.conf ]; then
+	if [[ "$lanaddr" != "`grep "set \$ip" /etc/nginx/conf.d/shortcuts.conf | head -n1 | cut -f 3 -d " " | sed -e 's/;//'`" ]]; then
+		sed -i "/set \$ip/c\set \$ip $lanaddr;" /etc/nginx/conf.d/shortcuts.conf
+		/etc/init.d/nginx reload
+	fi
+	cat /etc/nginx/conf.d/shortcuts.conf | tr "\n" "\r" |grep -oE 'server_name [a-z.-]*;[^;]*set \$ip [0-9.]*;' | sed -e 's/server_name \(.*\);.*location.*set $ip \(.*\);/\2 \1/' >>/tmp/hosts/shortcuts
+	cat /etc/nginx/conf.d/shortcuts.conf | tr "\n" "\r" |grep -oE 'server_name [a-z.-]*;[^;]*return 301 \$scheme://op' | sed -e 's/server_name \(.*\?\);.*/\1/' | sed -e "s/^/$lanaddr /">>/tmp/hosts/shortcuts
+	fi
+	fi
 
 	if [ "$mode" -gt 0 ] ; then
 		ifdashname="${ifname//./-}"
@@ -996,6 +1011,7 @@
 	append_bool "$cfg" noping "--no-ping"
 	append_bool "$cfg" rapidcommit "--dhcp-rapid-commit"
 	append_bool "$cfg" scriptarp "--script-arp"
+	append_parm "$cfg" mini_ttl "--min-ttl"
 
	# deprecate or remove filter-X in favor of filter-rr?
	append_bool "$cfg" filter_aaaa "--filter-AAAA"

--- a/package/network/services/odhcpd/files/odhcpd.defaults
+++ b/package/network/services/odhcpd/files/odhcpd.defaults
@@ -11,41 +11,21 @@
 json_select ..
 json_select ..
 
-ODHCPDONLY=0
-V4MODE=disabled
-V6MODE=disabled
-
-[ -e /usr/sbin/dnsmasq ] || ODHCPDONLY=1
-
 case "$protocol" in
 # only enable server mode on statically addressed lan ports
-"static")
-	V4MODE=server
-	;;
+"static") [ -e /proc/sys/net/ipv6 ] && MODE=server || MODE=disabled ;;
+*) MODE=disabled ;;
 esac
 
-uci get dhcp.lan 1>/dev/null 2>/dev/null || {
-uci batch <<EOF
-set dhcp.lan=dhcp
-set dhcp.lan.interface='lan'
-set dhcp.lan.start='100'
-set dhcp.lan.limit='150'
-set dhcp.lan.leasetime='12h'
-set dhcp.lan.domain='lan'
-EOF
-}
-
 uci batch <<EOF
 set dhcp.odhcpd=odhcpd
-set dhcp.odhcpd.maindhcp=$ODHCPDONLY
+set dhcp.odhcpd.maindhcp=0
 set dhcp.odhcpd.leasefile=/tmp/hosts/odhcpd
 set dhcp.odhcpd.leasetrigger=/usr/sbin/odhcpd-update
 set dhcp.odhcpd.loglevel=4
-set dhcp.lan.dhcpv4=$V4MODE
-set dhcp.lan.dhcpv6=$V6MODE
-set dhcp.lan.ra=$V6MODE
-set dhcp.lan.ra_slaac=1
+set dhcp.lan.ra=$MODE
+set dhcp.lan.dhcpv6=$MODE
 add_list dhcp.lan.ra_flags=other-config
 set dhcp.lan.max_preferred_lifetime=2700
 set dhcp.lan.max_valid_lifetime=5400
 commit dhcp

--- a/package/network/services/uhttpd/files/uhttpd.config
+++ b/package/network/services/uhttpd/files/uhttpd.config
@@ -1,151 +1,30 @@
-# Server configuration
-config uhttpd main
-
-	# HTTP listen addresses, multiple allowed
-	list listen_http	0.0.0.0:80
-	list listen_http	[::]:80
-
-	# HTTPS listen addresses, multiple allowed
-	list listen_https	0.0.0.0:443
-	list listen_https	[::]:443
-
-	# Redirect HTTP requests to HTTPS if possible
-	option redirect_https	0
-
-	# Server document root
-	option home		/www
-
-	# Reject requests from RFC1918 IP addresses
-	# directed to the servers public IP(s).
-	# This is a DNS rebinding countermeasure.
-	option rfc1918_filter 1
-
-	# Maximum number of concurrent requests.
-	# If this number is exceeded, further requests are
-	# queued until the number of running requests drops
-	# below the limit again.
-	option max_requests 3
-
-	# Maximum number of concurrent connections.
-	# If this number is exceeded, further TCP connection
-	# attempts are queued until the number of active
-	# connections drops below the limit again.
-	option max_connections 100
-
-	# Certificate and private key for HTTPS.
-	# If no listen_https addresses are given,
-	# the key options are ignored.
-	option cert		/etc/uhttpd.crt
-	option key		/etc/uhttpd.key
-
-	# CGI url prefix, will be searched in docroot.
-	# Default is /cgi-bin
-	option cgi_prefix	/cgi-bin
-
-	# List of extension->interpreter mappings.
-	# Files with an associated interpreter can
-	# be called outside of the CGI prefix and do
-	# not need to be executable.
-#	list interpreter	".php=/usr/bin/php-cgi"
-#	list interpreter	".cgi=/usr/bin/perl"
-
-	# List of prefix->Lua handler mappings.
-	# Any request to an URL beneath the prefix
-	# will be dispatched to the associated Lua
-	# handler script. Lua support is disabled when
-	# no handler mappings are specified. Lua prefix
-	# matches have precedence over the CGI prefix.
-	list lua_prefix		"/cgi-bin/luci=/usr/lib/lua/luci/sgi/uhttpd.lua"
-
-	# List of prefix->ucode handler mappings.
-	# Any request to an URL beneath the prefix
-	# will be dispatched to the associated ucode
-	# handler script. Ucode support is disabled when
-	# no handler mappings are specified. Ucode prefix
-	# matches have precedence over the CGI prefix.
-#	list ucode_prefix		"/ucode/example=/usr/share/example.uc"
-
-	# Specify the ubus-rpc prefix and socket path.
-#	option ubus_prefix	/ubus
-#	option ubus_socket	/var/run/ubus/ubus.sock
-
-	# CGI/Lua timeout, if the called script does not
-	# write data within the given amount of seconds,
-	# the server will terminate the request with
-	# 504 Gateway Timeout response.
-	option script_timeout	60
-
-	# Network timeout, if the current connection is
-	# blocked for the specified amount of seconds,
-	# the server will terminate the associated
-	# request process.
-	option network_timeout	30
-
-	# HTTP Keep-Alive, specifies the timeout for persistent
-	# HTTP/1.1 connections. Setting this to 0 will disable
-	# persistent HTTP connections.
-	option http_keepalive	20
-
-	# TCP Keep-Alive, send periodic keep-alive probes
-	# over established connections to detect dead peers.
-	# The value is given in seconds to specify the
-	# interval between subsequent probes.
-	# Setting this to 0 will disable TCP keep-alive.
-	option tcp_keepalive	1
-
-	# Basic auth realm, defaults to local hostname
-#	option realm	OpenWrt
-
-	# Configuration file in busybox httpd format
-#	option config	/etc/httpd.conf
-
-	# Do not follow symlinks that point outside of the
-	# home directory.
-#	option no_symlinks	0
-
-	# Do not produce directory listings but send 403
-	# instead if a client requests an url pointing to
-	# a directory without any index file.
-#	option no_dirlists	0
-
-	# Do not authenticate any ubus-rpc requests against
-	# the ubus session/access procedure.
-	# This is dangerous and should be always left off
-	# except for development and debug purposes!
-#	option no_ubusauth	0
-
-	# For this instance of uhttpd use the listed httpauth
-	# sections to require Basic auth to the specified
-	# resources.
-#	list httpauth prefix_user
-
-
-# Defaults for automatic certificate and key generation
-config cert defaults
-
-	# Validity time, 397 days is maximum allowed by CA/Browser forum
-	option days		397
-
-	# key type: rsa or ec
-	option key_type		ec
-
-	# RSA key size
-	option bits		256
-
-	# EC curve name
-	# Curve names vary between px5g-{wolfssl,mbedtls} and openssl
-	# P-256 or P-384 are guaranteed to work
-	option ec_curve		P-256
-
-	# Location
-	option country		ZZ
-	option state		Somewhere
-	option location		Unknown
-
-	# Common name
-	option commonname	'%D'
-
-# config httpauth prefix_user
-#	option prefix /protected/url/path
-#	option username user
-#	option password 'plaintext_or_md5_or_$p$user_for_system_user'
+config uhttpd 'main'
+	list listen_http '0.0.0.0:80'
+	list listen_http '[::]:80'
+	list listen_https '0.0.0.0:443'
+	list listen_https '[::]:443'
+	option redirect_https '0'
+	option home '/www'
+	option rfc1918_filter '1'
+	option max_requests '3'
+	option max_connections '100'
+	option cert '/etc/uhttpd.crt'
+	option key '/etc/uhttpd.key'
+	option cgi_prefix '/cgi-bin'
+	list lua_prefix '/cgi-bin/luci=/usr/lib/lua/luci/sgi/uhttpd.lua'
+	option script_timeout '60'
+	option network_timeout '30'
+	option http_keepalive '20'
+	option tcp_keepalive '1'
+	option ubus_prefix '/ubus'
+
+config cert 'defaults'
+	option days '730'
+	option key_type 'ec'
+	option bits '2048'
+	option ec_curve 'P-256'
+	option country 'ZZ'
+	option state 'Somewhere'
+	option location 'Unknown'
+	option commonname '%D'
+ 

--- a/package/utils/busybox/config/networking/Config.in
+++ b/package/utils/busybox/config/networking/Config.in
@@ -807,5 +807,19 @@
 	default BUSYBOX_DEFAULT_FEATURE_NSLOOKUP_LONG_OPTIONS
 	depends on BUSYBOX_CONFIG_FEATURE_NSLOOKUP_BIG && BUSYBOX_CONFIG_LONG_OPTS
+config BUSYBOX_CONFIG_NSLOOKUP_OPENWRT
+	bool "nslookup_openwrt"
+	depends on !BUSYBOX_CONFIG_NSLOOKUP
+	default BUSYBOX_DEFAULT_NSLOOKUP_OPENWRT
+	help
+	  nslookup is a tool to query Internet name servers (LEDE flavor).
+
+config BUSYBOX_CONFIG_FEATURE_NSLOOKUP_OPENWRT_LONG_OPTIONS
+       bool "Enable long options"
+       default BUSYBOX_DEFAULT_FEATURE_NSLOOKUP_OPENWRT_LONG_OPTIONS
+       depends on BUSYBOX_CONFIG_NSLOOKUP_OPENWRT && BUSYBOX_CONFIG_LONG_OPTS
+       help
+         Support long options for the nslookup applet.
+
 config BUSYBOX_CONFIG_NTPD
 	bool "ntpd (22 kb)"
 	default BUSYBOX_DEFAULT_NTPD

--- /dev/null
+++ b/package/utils/busybox/patches/230-add.patch
@@ -0,0 +1,971 @@
+From ab0f8bb80527928f513297ab93e3ec8c8b48dd50 Mon Sep 17 00:00:00 2001
+From: Jo-Philipp Wich <jo@mein.io>
+Date: Tue, 14 Mar 2017 22:21:34 +0100
+Subject: [PATCH] networking: add LEDE nslookup applet
+
+Add a new LEDE nslookup applet which is compatible with musl libc
+and providing more features like ability to specify query type.
+
+In contrast to busybox' builtin nslookup applet, this variant does
+not rely on libc resolver internals but uses explicit send logic
+and the libresolv primitives to parse received DNS responses.
+
+Signed-off-by: Jo-Philipp Wich <jo@mein.io>
+---
+ Makefile.flags             |   6 +
+ networking/nslookup_lede.c | 915 +++++++++++++++++++++++++++++++++++++++++++++
+ 2 files changed, 921 insertions(+)
+ create mode 100644 networking/nslookup_lede.c
+
+--- a/Makefile.flags
++++ b/Makefile.flags
+@@ -158,6 +158,12 @@ endif
+ # libm may be needed for dc, awk, ntpd
+ # librt may be needed for clock_gettime()
+ 
++# nslookup_lede might need the resolv library
++RESOLV_AVAILABLE := $(shell echo 'int main(void){res_init();return 0;}' >resolvtest.c; $(CC) $(CFLAGS) -include resolv.h -lresolv -o /dev/null resolvtest.c >/dev/null 2>&1 && echo "y"; rm resolvtest.c)
++ifeq ($(RESOLV_AVAILABLE),y)
++LDLIBS += resolv
++endif
++
+ # libpam may use libpthread, libdl and/or libaudit.
+ # On some platforms that requires an explicit -lpthread, -ldl, -laudit.
+ # However, on *other platforms* it fails when some of those flags
+--- /dev/null
++++ b/networking/nslookup_lede.c
+@@ -0,0 +1,934 @@
++/*
++ * nslookup_lede - musl compatible replacement for busybox nslookup
++ *
++ * Copyright (C) 2017 Jo-Philipp Wich <jo@mein.io>
++ *
++ * Permission to use, copy, modify, and/or distribute this software for any
++ * purpose with or without fee is hereby granted, provided that the above
++ * copyright notice and this permission notice appear in all copies.
++ *
++ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
++ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
++ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
++ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
++ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
++ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
++ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
++ */
++
++//config:config NSLOOKUP_OPENWRT
++//config:	bool "nslookup_openwrt"
++//config:	depends on !NSLOOKUP
++//config:	default y
++//config:	help
++//config:	  nslookup is a tool to query Internet name servers (LEDE flavor).
++//config:
++//config:config FEATURE_NSLOOKUP_OPENWRT_LONG_OPTIONS
++//config:       bool "Enable long options"
++//config:       default y
++//config:       depends on NSLOOKUP_OPENWRT && LONG_OPTS
++//config:       help
++//config:         Support long options for the nslookup applet.
++
++//applet:IF_NSLOOKUP_OPENWRT(APPLET(nslookup, BB_DIR_USR_BIN, BB_SUID_DROP))
++
++//kbuild:lib-$(CONFIG_NSLOOKUP_OPENWRT) += nslookup_lede.o
++
++//usage:#define nslookup_lede_trivial_usage
++//usage:       "[HOST] [SERVER]"
++//usage:#define nslookup_lede_full_usage "\n\n"
++//usage:       "Query the nameserver for the IP address of the given HOST\n"
++//usage:       "optionally using a specified DNS server"
++//usage:
++//usage:#define nslookup_lede_example_usage
++//usage:       "$ nslookup localhost\n"
++//usage:       "Server:     default\n"
++//usage:       "Address:    default\n"
++//usage:       "\n"
++//usage:       "Name:       debian\n"
++//usage:       "Address:    127.0.0.1\n"
++
++#include <stdio.h>
++#include <resolv.h>
++#include <string.h>
++#include <errno.h>
++#include <time.h>
++#include <poll.h>
++#include <unistd.h>
++#include <stdlib.h>
++#include <sys/socket.h>
++#include <arpa/inet.h>
++#include <net/if.h>
++#include <netdb.h>
++
++#include "libbb.h"
++
++struct ns {
++	const char *name;
++	len_and_sockaddr addr;
++	int failures;
++	int replies;
++};
++
++struct query {
++	const char *name;
++	size_t qlen, rlen;
++	unsigned char query[512], reply[512];
++	unsigned long latency;
++	int rcode, n_ns;
++};
++
++static struct {
++	int type;
++	const char *name;
++} qtypes[] = {
++	{ ns_t_soa,   "SOA"   },
++	{ ns_t_ns,    "NS"    },
++	{ ns_t_a,     "A"     },
++#if ENABLE_FEATURE_IPV6
++	{ ns_t_aaaa,  "AAAA"  },
++#endif
++	{ ns_t_cname, "CNAME" },
++	{ ns_t_mx,    "MX"    },
++	{ ns_t_txt,   "TXT"   },
++	{ ns_t_srv,   "SRV"   },
++	{ ns_t_ptr,   "PTR"   },
++	{ ns_t_any,   "ANY"   },
++	{ }
++};
++
++static const char *rcodes[] = {
++	"NOERROR",
++	"FORMERR",
++	"SERVFAIL",
++	"NXDOMAIN",
++	"NOTIMP",
++	"REFUSED",
++	"YXDOMAIN",
++	"YXRRSET",
++	"NXRRSET",
++	"NOTAUTH",
++	"NOTZONE",
++	"RESERVED11",
++	"RESERVED12",
++	"RESERVED13",
++	"RESERVED14",
++	"RESERVED15",
++	"BADVERS"
++};
++
++static unsigned int default_port = 53;
++static unsigned int default_retry = 2;
++static unsigned int default_timeout = 5;
++
++
++static int parse_reply(const unsigned char *msg, size_t len, int *bb_style_counter)
++{
++	ns_msg handle;
++	ns_rr rr;
++	int i, n, rdlen;
++	const char *format = NULL;
++	char astr[INET6_ADDRSTRLEN], dname[MAXDNAME];
++	const unsigned char *cp;
++
++	if (ns_initparse(msg, len, &handle) != 0) {
++		//fprintf(stderr, "Unable to parse reply: %s\n", strerror(errno));
++		return -1;
++	}
++
++	for (i = 0; i < ns_msg_count(handle, ns_s_an); i++) {
++		if (ns_parserr(&handle, ns_s_an, i, &rr) != 0) {
++			//fprintf(stderr, "Unable to parse resource record: %s\n", strerror(errno));
++			return -1;
++		}
++
++		if (bb_style_counter && *bb_style_counter == 1)
++			printf("Name:      %s\n", ns_rr_name(rr));
++
++		rdlen = ns_rr_rdlen(rr);
++
++		switch (ns_rr_type(rr))
++		{
++		case ns_t_a:
++			if (rdlen != 4) {
++				//fprintf(stderr, "Unexpected A record length\n");
++				return -1;
++			}
++			inet_ntop(AF_INET, ns_rr_rdata(rr), astr, sizeof(astr));
++			if (bb_style_counter)
++				printf("Address %d: %s\n", (*bb_style_counter)++, astr);
++			else
++				printf("Name:\t%s\nAddress: %s\n", ns_rr_name(rr), astr);
++			break;
++
++#if ENABLE_FEATURE_IPV6
++		case ns_t_aaaa:
++			if (rdlen != 16) {
++				//fprintf(stderr, "Unexpected AAAA record length\n");
++				return -1;
++			}
++			inet_ntop(AF_INET6, ns_rr_rdata(rr), astr, sizeof(astr));
++			if (bb_style_counter)
++				printf("Address %d: %s\n", (*bb_style_counter)++, astr);
++			else
++				printf("%s\thas AAAA address %s\n", ns_rr_name(rr), astr);
++			break;
++#endif
++
++		case ns_t_ns:
++			if (!format)
++				format = "%s\tnameserver = %s\n";
++			/* fall through */
++
++		case ns_t_cname:
++			if (!format)
++				format = "%s\tcanonical name = %s\n";
++			/* fall through */
++
++		case ns_t_ptr:
++			if (!format)
++				format = "%s\tname = %s\n";
++			if (ns_name_uncompress(ns_msg_base(handle), ns_msg_end(handle),
++				ns_rr_rdata(rr), dname, sizeof(dname)) < 0) {
++				//fprintf(stderr, "Unable to uncompress domain: %s\n", strerror(errno));
++				return -1;
++			}
++			printf(format, ns_rr_name(rr), dname);
++			break;
++
++		case ns_t_mx:
++			if (rdlen < 2) {
++				fprintf(stderr, "MX record too short\n");
++				return -1;
++			}
++			n = ns_get16(ns_rr_rdata(rr));
++			if (ns_name_uncompress(ns_msg_base(handle), ns_msg_end(handle),
++				ns_rr_rdata(rr) + 2, dname, sizeof(dname)) < 0) {
++				//fprintf(stderr, "Cannot uncompress MX domain: %s\n", strerror(errno));
++				return -1;
++			}
++			printf("%s\tmail exchanger = %d %s\n", ns_rr_name(rr), n, dname);
++			break;
++
++		case ns_t_txt:
++			if (rdlen < 1) {
++				//fprintf(stderr, "TXT record too short\n");
++				return -1;
++			}
++			n = *(unsigned char *)ns_rr_rdata(rr);
++			if (n > 0) {
++				memset(dname, 0, sizeof(dname));
++				memcpy(dname, ns_rr_rdata(rr) + 1, n);
++				printf("%s\ttext = \"%s\"\n", ns_rr_name(rr), dname);
++			}
++			break;
++
++		case ns_t_srv:
++			if (rdlen < 6) {
++				//printf("SRV record too short\n");
++				return -1;
++			}
++
++			cp = ns_rr_rdata(rr);
++			n = ns_name_uncompress(ns_msg_base(handle), ns_msg_end(handle),
++			                       cp + 6, dname, sizeof(dname));
++
++			if (n < 0) {
++				//printf("Unable to uncompress domain: %s\n", strerror(errno));
++				return -1;
++			}
++
++			printf("%s\tservice = %hu %hu %hu %s\n", ns_rr_name(rr),
++				ns_get16(cp), ns_get16(cp + 2), ns_get16(cp + 4), dname);
++			break;
++
++		case ns_t_soa:
++			if (rdlen < 20) {
++				//fprintf(stderr, "SOA record too short\n");
++				return -1;
++			}
++
++			printf("%s\n", ns_rr_name(rr));
++
++			cp = ns_rr_rdata(rr);
++			n = ns_name_uncompress(ns_msg_base(handle), ns_msg_end(handle),
++			                       cp, dname, sizeof(dname));
++
++			if (n < 0) {
++				//fprintf(stderr, "Unable to uncompress domain: %s\n", strerror(errno));
++				return -1;
++			}
++
++			printf("\torigin = %s\n", dname);
++			cp += n;
++
++			n = ns_name_uncompress(ns_msg_base(handle), ns_msg_end(handle),
++			                       cp, dname, sizeof(dname));
++
++			if (n < 0) {
++				//fprintf(stderr, "Unable to uncompress domain: %s\n", strerror(errno));
++				return -1;
++			}
++
++			printf("\tmail addr = %s\n", dname);
++			cp += n;
++
++			printf("\tserial = %lu\n", ns_get32(cp));
++			cp += 4;
++
++			printf("\trefresh = %lu\n", ns_get32(cp));
++			cp += 4;
++
++			printf("\tretry = %lu\n", ns_get32(cp));
++			cp += 4;
++
++			printf("\texpire = %lu\n", ns_get32(cp));
++			cp += 4;
++
++			printf("\tminimum = %lu\n", ns_get32(cp));
++			break;
++
++		default:
++			break;
++		}
++	}
++
++	return i;
++}
++
++static int parse_nsaddr(const char *addrstr, len_and_sockaddr *lsa)
++{
++	char *eptr, *hash, ifname[IFNAMSIZ];
++	unsigned int port = default_port;
++	unsigned int scope = 0;
++
++	hash = strchr(addrstr, '#');
++
++	if (hash) {
++		*hash++ = '\0';
++		port = strtoul(hash, &eptr, 10);
++
++		if (eptr == hash || *eptr != '\0' || port > 65535) {
++			errno = EINVAL;
++			return -1;
++		}
++	}
++
++	hash = strchr(addrstr, '%');
++
++	if (hash) {
++		for (eptr = ++hash; *eptr != '\0' && *eptr != '#'; eptr++) {
++			if ((eptr - hash) >= IFNAMSIZ) {
++				errno = ENODEV;
++				return -1;
++			}
++
++			ifname[eptr - hash] = *eptr;
++		}
++
++		ifname[eptr - hash] = '\0';
++		scope = if_nametoindex(ifname);
++
++		if (scope == 0) {
++			errno = ENODEV;
++			return -1;
++		}
++	}
++
++#if ENABLE_FEATURE_IPV6
++	if (inet_pton(AF_INET6, addrstr, &lsa->u.sin6.sin6_addr)) {
++		lsa->u.sin6.sin6_family = AF_INET6;
++		lsa->u.sin6.sin6_port = htons(port);
++		lsa->u.sin6.sin6_scope_id = scope;
++		lsa->len = sizeof(lsa->u.sin6);
++		return 0;
++	}
++#endif
++
++	if (!scope && inet_pton(AF_INET, addrstr, &lsa->u.sin.sin_addr)) {
++		lsa->u.sin.sin_family = AF_INET;
++		lsa->u.sin.sin_port = htons(port);
++		lsa->len = sizeof(lsa->u.sin);
++		return 0;
++	}
++
++	errno = EINVAL;
++	return -1;
++}
++
++static char *make_ptr(const char *addrstr)
++{
++	const char *hexdigit = "0123456789abcdef";
++	static char ptrstr[73];
++	unsigned char addr[16];
++	char *ptr = ptrstr;
++	int i;
++
++	if (inet_pton(AF_INET6, addrstr, addr)) {
++		if (memcmp(addr, "\0\0\0\0\0\0\0\0\0\0\xff\xff", 12) != 0) {
++			for (i = 0; i < 16; i++) {
++				*ptr++ = hexdigit[(unsigned char)addr[15 - i] & 0xf];
++				*ptr++ = '.';
++				*ptr++ = hexdigit[(unsigned char)addr[15 - i] >> 4];
++				*ptr++ = '.';
++			}
++			strcpy(ptr, "ip6.arpa");
++		}
++		else {
++			sprintf(ptr, "%u.%u.%u.%u.in-addr.arpa",
++			        addr[15], addr[14], addr[13], addr[12]);
++		}
++
++		return ptrstr;
++	}
++
++	if (inet_pton(AF_INET, addrstr, addr)) {
++		sprintf(ptr, "%u.%u.%u.%u.in-addr.arpa",
++		        addr[3], addr[2], addr[1], addr[0]);
++		return ptrstr;
++	}
++
++	return NULL;
++}
++
++static unsigned long mtime(void)
++{
++	struct timespec ts;
++	clock_gettime(CLOCK_REALTIME, &ts);
++	return (unsigned long)ts.tv_sec * 1000 + ts.tv_nsec / 1000000;
++}
++
++#if ENABLE_FEATURE_IPV6
++static void to_v4_mapped(len_and_sockaddr *a)
++{
++	if (a->u.sa.sa_family != AF_INET)
++		return;
++
++	memcpy(a->u.sin6.sin6_addr.s6_addr + 12,
++	       &a->u.sin.sin_addr, 4);
++
++	memcpy(a->u.sin6.sin6_addr.s6_addr,
++	       "\0\0\0\0\0\0\0\0\0\0\xff\xff", 12);
++
++	a->u.sin6.sin6_family = AF_INET6;
++	a->u.sin6.sin6_flowinfo = 0;
++	a->u.sin6.sin6_scope_id = 0;
++	a->len = sizeof(a->u.sin6);
++}
++#endif
++
++
++/*
++ * Function logic borrowed & modified from musl libc, res_msend.c
++ */
++
++static int send_queries(struct ns *ns, int n_ns, struct query *queries, int n_queries)
++{
++	int fd;
++	int timeout = default_timeout * 1000, retry_interval, servfail_retry = 0;
++	len_and_sockaddr from = { };
++#if ENABLE_FEATURE_IPV6
++	int one = 1;
++#endif
++	int recvlen = 0;
++	int n_replies = 0;
++	struct pollfd pfd;
++	unsigned long t0, t1, t2;
++	int nn, qn, next_query = 0;
++
++	from.u.sa.sa_family = AF_INET;
++	from.len = sizeof(from.u.sin);
++
++#if ENABLE_FEATURE_IPV6
++	for (nn = 0; nn < n_ns; nn++) {
++		if (ns[nn].addr.u.sa.sa_family == AF_INET6) {
++			from.u.sa.sa_family = AF_INET6;
++			from.len = sizeof(from.u.sin6);
++			break;
++		}
++	}
++#endif
++
++	/* Get local address and open/bind a socket */
++	fd = socket(from.u.sa.sa_family, SOCK_DGRAM|SOCK_CLOEXEC|SOCK_NONBLOCK, 0);
++
++#if ENABLE_FEATURE_IPV6
++	/* Handle case where system lacks IPv6 support */
++	if (fd < 0 && from.u.sa.sa_family == AF_INET6 && errno == EAFNOSUPPORT) {
++		fd = socket(AF_INET, SOCK_DGRAM|SOCK_CLOEXEC|SOCK_NONBLOCK, 0);
++		from.u.sa.sa_family = AF_INET;
++	}
++#endif
++
++	if (fd < 0)
++		return -1;
++
++	if (bind(fd, &from.u.sa, from.len) < 0) {
++		close(fd);
++		return -1;
++	}
++
++#if ENABLE_FEATURE_IPV6
++	/* Convert any IPv4 addresses in a mixed environment to v4-mapped */
++	if (from.u.sa.sa_family == AF_INET6) {
++		setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &one, sizeof(one));
++
++		for (nn = 0; nn < n_ns; nn++)
++			to_v4_mapped(&ns[nn].addr);
++	}
++#endif
++
++	pfd.fd = fd;
++	pfd.events = POLLIN;
++	retry_interval = timeout / default_retry;
++	t0 = t2 = mtime();
++	t1 = t2 - retry_interval;
++
++	for (; t2 - t0 < timeout; t2 = mtime()) {
++		if (t2 - t1 >= retry_interval) {
++			for (qn = 0; qn < n_queries; qn++) {
++				if (queries[qn].rlen)
++					continue;
++
++				for (nn = 0; nn < n_ns; nn++) {
++					sendto(fd, queries[qn].query, queries[qn].qlen,
++					       MSG_NOSIGNAL, &ns[nn].addr.u.sa, ns[nn].addr.len);
++				}
++			}
++
++			t1 = t2;
++			servfail_retry = 2 * n_queries;
++		}
++
++		/* Wait for a response, or until time to retry */
++		if (poll(&pfd, 1, t1+retry_interval-t2) <= 0)
++			continue;
++
++		while (1) {
++			recvlen = recvfrom(fd, queries[next_query].reply,
++			                   sizeof(queries[next_query].reply), 0,
++			                   &from.u.sa, &from.len);
++
++			/* read error */
++			if (recvlen < 0)
++				break;
++
++			/* Ignore non-identifiable packets */
++			if (recvlen < 4)
++				continue;
++
++			/* Ignore replies from addresses we didn't send to */
++			for (nn = 0; nn < n_ns; nn++)
++				if (memcmp(&from.u.sa, &ns[nn].addr.u.sa, from.len) == 0)
++					break;
++
++			if (nn >= n_ns)
++				continue;
++
++			/* Find which query this answer goes with, if any */
++			for (qn = next_query; qn < n_queries; qn++)
++				if (!memcmp(queries[next_query].reply, queries[qn].query, 2))
++					break;
++
++			if (qn >= n_queries || queries[qn].rlen)
++				continue;
++
++			queries[qn].rcode = queries[next_query].reply[3] & 15;
++			queries[qn].latency = mtime() - t0;
++			queries[qn].n_ns = nn;
++
++			ns[nn].replies++;
++
++			/* Only accept positive or negative responses;
++			 * retry immediately on server failure, and ignore
++			 * all other codes such as refusal. */
++			switch (queries[qn].rcode) {
++			case 0:
++			case 3:
++				break;
++
++			case 2:
++				if (servfail_retry && servfail_retry--) {
++					ns[nn].failures++;
++					sendto(fd, queries[qn].query, queries[qn].qlen,
++					       MSG_NOSIGNAL, &ns[nn].addr.u.sa, ns[nn].addr.len);
++				}
++				/* fall through */
++
++			default:
++				continue;
++			}
++
++			/* Store answer */
++			n_replies++;
++
++			queries[qn].rlen = recvlen;
++
++			if (qn == next_query) {
++				while (next_query < n_queries) {
++					if (!queries[next_query].rlen)
++						break;
++
++					next_query++;
++				}
++			}
++			else {
++				memcpy(queries[qn].reply, queries[next_query].reply, recvlen);
++			}
++
++			if (next_query >= n_queries)
++				return n_replies;
++		}
++	}
++
++	return n_replies;
++}
++
++static struct ns *add_ns(struct ns **ns, int *n_ns, const char *addr)
++{
++	char portstr[sizeof("65535")], *p;
++	len_and_sockaddr a = { };
++	struct ns *tmp;
++	struct addrinfo *ai, *aip, hints = {
++		.ai_flags = AI_NUMERICSERV,
++		.ai_socktype = SOCK_DGRAM
++	};
++
++	if (parse_nsaddr(addr, &a)) {
++		/* Maybe we got a domain name, attempt to resolve it using the standard
++		 * resolver routines */
++
++		p = strchr(addr, '#');
++		snprintf(portstr, sizeof(portstr), "%hu",
++		         (unsigned short)(p ? strtoul(p, NULL, 10) : default_port));
++
++		if (!getaddrinfo(addr, portstr, &hints, &ai)) {
++			for (aip = ai; aip; aip = aip->ai_next) {
++				if (aip->ai_addr->sa_family != AF_INET &&
++				    aip->ai_addr->sa_family != AF_INET6)
++					continue;
++
++#if ! ENABLE_FEATURE_IPV6
++				if (aip->ai_addr->sa_family != AF_INET)
++					continue;
++#endif
++
++				tmp = realloc(*ns, sizeof(**ns) * (*n_ns + 1));
++
++				if (!tmp)
++					return NULL;
++
++				*ns = tmp;
++
++				(*ns)[*n_ns].name = addr;
++				(*ns)[*n_ns].replies = 0;
++				(*ns)[*n_ns].failures = 0;
++				(*ns)[*n_ns].addr.len = aip->ai_addrlen;
++
++				memcpy(&(*ns)[*n_ns].addr.u.sa, aip->ai_addr, aip->ai_addrlen);
++
++				(*n_ns)++;
++			}
++
++			freeaddrinfo(ai);
++
++			return &(*ns)[*n_ns];
++		}
++
++		return NULL;
++	}
++
++	tmp = realloc(*ns, sizeof(**ns) * (*n_ns + 1));
++
++	if (!tmp)
++		return NULL;
++
++	*ns = tmp;
++
++	(*ns)[*n_ns].addr = a;
++	(*ns)[*n_ns].name = addr;
++	(*ns)[*n_ns].replies = 0;
++	(*ns)[*n_ns].failures = 0;
++
++	return &(*ns)[(*n_ns)++];
++}
++
++static int parse_resolvconf(struct ns **ns, int *n_ns)
++{
++	int prev_n_ns = *n_ns;
++	char line[128], *p;
++	FILE *resolv;
++
++	if ((resolv = fopen("/etc/resolv.conf", "r")) != NULL) {
++		while (fgets(line, sizeof(line), resolv)) {
++			p = strtok(line, " \t\n");
++
++			if (!p || strcmp(p, "nameserver"))
++				continue;
++
++			p = strtok(NULL, " \t\n");
++
++			if (!p)
++				continue;
++
++			if (!add_ns(ns, n_ns, strdup(p))) {
++				free(p);
++				break;
++			}
++		}
++
++		fclose(resolv);
++	}
++
++	return *n_ns - prev_n_ns;
++}
++
++static struct query *add_query(struct query **queries, int *n_queries,
++                               int type, const char *dname)
++{
++	struct query *tmp;
++	ssize_t qlen;
++
++	tmp = realloc(*queries, sizeof(**queries) * (*n_queries + 1));
++
++	if (!tmp)
++		return NULL;
++
++	memset(&tmp[*n_queries], 0, sizeof(*tmp));
++
++	qlen = res_mkquery(QUERY, dname, C_IN, type, NULL, 0, NULL,
++	                   tmp[*n_queries].query, sizeof(tmp[*n_queries].query));
++
++	tmp[*n_queries].qlen = qlen;
++	tmp[*n_queries].name = dname;
++	*queries = tmp;
++
++	return &tmp[(*n_queries)++];
++}
++
++static char *sal2str(len_and_sockaddr *a)
++{
++	static char buf[INET6_ADDRSTRLEN + 1 + IFNAMSIZ + 1 + 5 + 1];
++	char *p = buf;
++
++#if ENABLE_FEATURE_IPV6
++	if (a->u.sa.sa_family == AF_INET6) {
++		inet_ntop(AF_INET6, &a->u.sin6.sin6_addr, buf, sizeof(buf));
++		p += strlen(p);
++
++		if (a->u.sin6.sin6_scope_id) {
++			if (if_indextoname(a->u.sin6.sin6_scope_id, p + 1)) {
++				*p++ = '%';
++				p += strlen(p);
++			}
++		}
++	}
++	else
++#endif
++	{
++		inet_ntop(AF_INET, &a->u.sin.sin_addr, buf, sizeof(buf));
++		p += strlen(p);
++	}
++
++	sprintf(p, "#%hu", ntohs(a->u.sin.sin_port));
++
++	return buf;
++}
++
++int nslookup_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
++int nslookup_main(int argc, char **argv)
++{
++	int rc = 1;
++	char *ptr, *chr;
++	struct ns *ns = NULL;
++	struct query *queries = NULL;
++	llist_t *type_strings = NULL;
++	int n_ns = 0, n_queries = 0;
++	int c, opts, option_index = 0;
++	int stats = 0, bb_style_counter = 0;
++	unsigned int types = 0;
++	HEADER *header;
++
++#if ENABLE_FEATURE_NSLOOKUP_OPENWRT_LONG_OPTIONS
++	static const char nslookup_longopts[] ALIGN1 =
++		"type\0"		Required_argument	"q"
++		"querytype\0"		Required_argument	"q"
++		"port\0"		Required_argument	"p"
++		"retry\0"		Required_argument	"r"
++		"timeout\0"		Required_argument	"t"
++		"stats\0"		No_argument		"s"
++	;
++
++	opts = getopt32long(argv, "^" "+q:*p:+r:+t:+s" "\0" "q::",
++			nslookup_longopts,
++	                &type_strings, &default_port,
++	                &default_retry, &default_timeout);
++#else
++	opts = getopt32(argv, "^" "+q:*p:+r:+t:+s" "\0" "q::",
++	                &type_strings, &default_port,
++	                &default_retry, &default_timeout);
++#endif
++
++	while (type_strings) {
++		ptr = llist_pop(&type_strings);
++
++		/* skip leading text, e.g. when invoked with -querytype=AAAA */
++		if ((chr = strchr(ptr, '=')) != NULL)
++			ptr = chr + 1;
++
++		for (c = 0; qtypes[c].name; c++)
++			if (!strcmp(qtypes[c].name, ptr))
++				break;
++
++		if (!qtypes[c].name) {
++			fprintf(stderr, "Invalid query type \"%s\"\n", ptr);
++			goto out;
++		}
++
++		types |= (1 << c);
++	}
++
++	if (default_port > 65535) {
++		fprintf(stderr, "Invalid server port\n");
++		goto out;
++	}
++
++	if (!default_retry) {
++		fprintf(stderr, "Invalid retry value\n");
++		goto out;
++	}
++
++	if (!default_timeout) {
++		fprintf(stderr, "Invalid timeout value\n");
++		goto out;
++	}
++
++	stats = (opts & 16);
++
++	if (optind >= argc)
++		bb_show_usage();
++
++	for (option_index = optind;
++	     option_index < ((argc - optind) > 1 ? argc - 1 : argc);
++	     option_index++) {
++
++		/* No explicit type given, guess query type.
++		 * If we can convert the domain argument into a ptr (means that
++		 * inet_pton() could read it) we assume a PTR request, else
++		 * we issue A+AAAA queries and switch to an output format
++		 * mimicking the one of the traditional nslookup applet. */
++		if (types == 0) {
++			ptr = make_ptr(argv[option_index]);
++
++			if (ptr) {
++				add_query(&queries, &n_queries, T_PTR, ptr);
++			}
++			else {
++				bb_style_counter = 1;
++				add_query(&queries, &n_queries, T_A, argv[option_index]);
++#if ENABLE_FEATURE_IPV6
++				add_query(&queries, &n_queries, T_AAAA, argv[option_index]);
++#endif
++			}
++		}
++		else {
++			for (c = 0; qtypes[c].name; c++)
++				if (types & (1 << c))
++					add_query(&queries, &n_queries, qtypes[c].type,
++					          argv[option_index]);
++		}
++	}
++
++	/* Use given DNS server if present */
++	if (option_index < argc) {
++		if (!add_ns(&ns, &n_ns, argv[option_index])) {
++			fprintf(stderr, "Invalid NS server address \"%s\": %s\n",
++			        argv[option_index], strerror(errno));
++			goto out;
++		}
++	}
++	else {
++		parse_resolvconf(&ns, &n_ns);
++	}
++
++	/* Fall back to localhost if we could not find NS in resolv.conf */
++	if (n_ns == 0) {
++		add_ns(&ns, &n_ns, "127.0.0.1");
++	}
++
++	for (c = 0; c < n_ns; c++) {
++		rc = send_queries(&ns[c], 1, queries, n_queries);
++
++		if (rc < 0) {
++			fprintf(stderr, "Failed to send queries: %s\n", strerror(errno));
++			goto out;
++		} else if (rc > 0) {
++			break;
++		}
++	}
++
++	if (c >= n_ns) {
++		fprintf(stderr,
++			    ";; connection timed out; no servers could be reached\n\n");
++
++		return 1;
++	}
++
++	printf("Server:\t\t%s\n", ns[c].name);
++	printf("Address:\t%s\n", sal2str(&ns[c].addr));
++
++	if (stats) {
++		printf("Replies:\t%d\n", ns[c].replies);
++		printf("Failures:\t%d\n", ns[c].failures);
++	}
++
++	printf("\n");
++
++	for (rc = 0; rc < n_queries; rc++) {
++		if (stats) {
++			printf("Query #%d completed in %lums:\n", rc, queries[rc].latency);
++		}
++
++		if (queries[rc].rcode != 0) {
++			printf("** server can't find %s: %s\n", queries[rc].name,
++			       rcodes[queries[rc].rcode]);
++			continue;
++		}
++
++		c = 0;
++
++		if (queries[rc].rlen) {
++			if (!bb_style_counter) {
++				header = (HEADER *)queries[rc].reply;
++
++				if (!header->aa)
++					printf("Non-authoritative answer:\n");
++
++				c = parse_reply(queries[rc].reply, queries[rc].rlen, NULL);
++			}
++			else {
++				c = parse_reply(queries[rc].reply, queries[rc].rlen,
++				                &bb_style_counter);
++			}
++		}
++
++		if (c == 0)
++			printf("*** Can't find %s: No answer\n", queries[rc].name);
++		else if (c < 0)
++			printf("*** Can't find %s: Parse error\n", queries[rc].name);
++
++		if (!bb_style_counter)
++			printf("\n");
++	}
++
++	rc = 0;
++
++out:
++	if (n_ns)
++		free(ns);
++
++	if (n_queries)
++		free(queries);
++
++	return rc;
++}

--- a/package/utils/busybox/Config-defaults.in
+++ b/package/utils/busybox/Config-defaults.in
@@ -2525,13 +2525,19 @@
 	default y
 config BUSYBOX_DEFAULT_NSLOOKUP
 	bool
-	default y
+	default n
 config BUSYBOX_DEFAULT_FEATURE_NSLOOKUP_BIG
 	bool
-	default y
+	default n
 config BUSYBOX_DEFAULT_FEATURE_NSLOOKUP_LONG_OPTIONS
 	bool
 	default n
+config BUSYBOX_DEFAULT_NSLOOKUP_OPENWRT
+	bool
+	default y
+config BUSYBOX_DEFAULT_FEATURE_NSLOOKUP_OPENWRT_LONG_OPTIONS
+	bool
+	default n
 config BUSYBOX_DEFAULT_NTPD
 	bool
 	default y

--- a/package/utils/busybox/Makefile
+++ b/package/utils/busybox/Makefile
@@ -101,7 +101,7 @@
 LDLIBS += $(call BUSYBOX_IF_ENABLED,PAM,pam pam_misc pthread)
 
 ifeq ($(CONFIG_USE_GLIBC),y)
-  LDLIBS += $(call BUSYBOX_IF_ENABLED,NSLOOKUP,resolv)
+  LDLIBS += $(call BUSYBOX_IF_ENABLED,NSLOOKUP_OPENWRT,resolv)
 endif
 
 ifeq ($(BUILD_VARIANT),selinux)

--- /dev/null
+++ b/tools/ucl/Makefile
@@ -0,0 +1,51 @@
+#
+# Copyright (C) 2019 OpenWrt.org
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+include $(TOPDIR)/rules.mk
+
+PKG_NAME:=ucl
+PKG_VERSION:=1.03
+
+PKG_SOURCE:=$(PKG_NAME)-$(PKG_VERSION).tar.gz
+PKG_SOURCE_URL:=http://www.oberhumer.com/opensource/ucl/download/$(PKG_SOURCE)
+PKG_HASH:=b865299ffd45d73412293369c9754b07637680e5c826915f097577cd27350348
+
+HOST_BUILD_DIR:=$(BUILD_DIR_HOST)/$(PKG_NAME)-$(PKG_VERSION)
+
+include $(INCLUDE_DIR)/host-build.mk
+
+HOSTCC :=gcc
+HOST_CFLAGS +=-std=gnu89
+
+define Host/Prepare
+	$(Host/Prepare/Default)
+	mkdir -p $(STAGING_DIR_HOST)/include/ucl
+endef
+
+define Host/Configure
+	(cd $(HOST_BUILD_DIR); \
+	CC="$(HOSTCC)" \
+	CFLAGS="$(HOST_CFLAGS)" \
+	./configure --prefix=$(STAGING_DIR_HOST) \
+	);
+	$(call Host/Configure/Default)
+endef
+
+define Host/Compile
+	$(MAKE) -C $(HOST_BUILD_DIR)
+endef
+
+define Host/Install
+	$(MAKE) -C $(HOST_BUILD_DIR) install
+endef
+
+define Host/Clean
+	$(MAKE) -C $(HOST_BUILD_DIR) uninstall
+	rm -rf $(HOST_BUILD_DIR)
+	rm -rf $(STAGING_DIR_HOST)/include/ucl
+endef
+
+$(eval $(call HostBuild))

--- /dev/null
+++ b/tools/upx/Makefile
@@ -0,0 +1,66 @@
+#
+# Copyright (C) 2011-2022 OpenWrt.org
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+include $(TOPDIR)/rules.mk
+
+PKG_NAME:=upx
+PKG_RELEASE:=1
+
+PKG_MAINTAINER:=Xingwang Liao <kuoruan@gmail.com>
+PKG_LICENSE:=GPL-2.0-only
+PKG_LICENSE_FILES:=COPYING LICENSE
+
+PKG_SOURCE_PROTO:=git
+PKG_SOURCE_DATE:=2024-05-09
+PKG_SOURCE_VERSION:=3757579ffc6fa8710b4b7a1055529fea9dcaf149
+PKG_SOURCE_URL:=https://github.com/upx/upx.git
+PKG_SOURCE:=$(PKG_NAME)-$(PKG_SOURCE_DATE).tar.gz
+
+HOST_BUILD_DEPENDS:=ucl/host
+
+include $(INCLUDE_DIR)/host-build.mk
+include $(INCLUDE_DIR)/package.mk
+
+define Host/Compile
+	UPX_UCLDIR=$(STAGING_DIR_HOST) \
+	$(MAKE) -C $(HOST_BUILD_DIR)/src \
+		CXXFLAGS_WERROR="" LDFLAGS="$(HOST_LDFLAGS)" \
+		CXX="$(HOSTCXX)"
+endef
+
+define Host/Install
+	$(CP) $(HOST_BUILD_DIR)/src/upx.out $(STAGING_DIR_HOST)/bin/upx
+endef
+
+define Host/Clean
+	rm -f $(STAGING_DIR_HOST)/bin/upx
+endef
+
+define Package/upx
+  SECTION:=utils
+  CATEGORY:=Utilities
+  DEPENDS:=+libucl +libstdcpp +zlib
+  TITLE:=The Ultimate Packer for eXecutables
+  URL:=https://upx.github.io/
+endef
+
+define Package/upx/description
+UPX is a free, portable, extendable, high-performance executable packer for
+several different executable formats. It achieves an excellent compression ratio
+and offers very fast decompression. Your executables suffer no memory overhead
+or other drawbacks for most of the formats supported, because of in-place
+decompression.
+endef
+
+MAKE_PATH := src
+
+define Package/upx/install
+	$(INSTALL_DIR) $(1)/usr/bin
+	$(INSTALL_BIN) $(PKG_BUILD_DIR)/src/upx.out $(1)/usr/bin/upx
+endef
+
+$(eval $(call HostBuild))
+$(eval $(call BuildPackage,upx))

--- a/tools/Makefile
+++ b/tools/Makefile
@@ -70,6 +70,7 @@
 tools-y += xz
 tools-y += zip
 tools-y += zlib
+tools-y += ucl upx
 tools-$(if $(CONFIG_BUILD_ALL_HOST_TOOLS),y) += liblzo
 tools-$(if $(CONFIG_BUILD_ALL_HOST_TOOLS)$(BUILD_B43_TOOLS),y) += b43-tools
 tools-$(if $(CONFIG_BUILD_ALL_HOST_TOOLS)$(BUILD_BZIP2_TOOLS),y) += bzip2
@@ -89,6 +90,7 @@
 tools-$(if $(CONFIG_BUILD_ALL_HOST_TOOLS)$(CONFIG_USE_MOLD),y) += mold
 
 # builddir dependencies
+$(curdir)/upx/compile := $(curdir)/ucl/compile
 $(curdir)/autoconf/compile := $(curdir)/m4/compile
 $(curdir)/automake/compile := $(curdir)/autoconf/compile $(curdir)/pkgconf/compile $(curdir)/xz/compile
 $(curdir)/b43-tools/compile := $(curdir)/bison/compile
